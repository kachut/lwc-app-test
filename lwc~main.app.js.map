{"version":3,"sources":["webpack:///./node_modules/@lwc/engine/lib/3rdparty/snabbdom/snabbdom.js","webpack:///./node_modules/@lwc/engine/lib/env/dom.js","webpack:///./node_modules/@lwc/engine/lib/env/element.js","webpack:///./node_modules/@lwc/engine/lib/env/node.js","webpack:///./node_modules/@lwc/engine/lib/framework/api.js","webpack:///./node_modules/@lwc/engine/lib/framework/attributes.js","webpack:///./node_modules/@lwc/engine/lib/framework/base-bridge-element.js","webpack:///./node_modules/@lwc/engine/lib/framework/base-lightning-element.js","webpack:///./node_modules/@lwc/engine/lib/framework/component.js","webpack:///./node_modules/@lwc/engine/lib/framework/context.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/api.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/decorate.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/readonly.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/register.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/track.js","webpack:///./node_modules/@lwc/engine/lib/framework/decorators/wire.js","webpack:///./node_modules/@lwc/engine/lib/framework/def.js","webpack:///./node_modules/@lwc/engine/lib/framework/hooks.js","webpack:///./node_modules/@lwc/engine/lib/framework/html-properties.js","webpack:///./node_modules/@lwc/engine/lib/framework/invoker.js","webpack:///./node_modules/@lwc/engine/lib/framework/main.js","webpack:///./node_modules/@lwc/engine/lib/framework/membrane.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/attrs.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/computed-class-attr.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/computed-style-attr.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/context.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/events.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/props.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/static-class-attr.js","webpack:///./node_modules/@lwc/engine/lib/framework/modules/static-style-attr.js","webpack:///./node_modules/@lwc/engine/lib/framework/patch.js","webpack:///./node_modules/@lwc/engine/lib/framework/performance-timing.js","webpack:///./node_modules/@lwc/engine/lib/framework/restrictions.js","webpack:///./node_modules/@lwc/engine/lib/framework/secure-template.js","webpack:///./node_modules/@lwc/engine/lib/framework/services.js","webpack:///./node_modules/@lwc/engine/lib/framework/stylesheet.js","webpack:///./node_modules/@lwc/engine/lib/framework/template.js","webpack:///./node_modules/@lwc/engine/lib/framework/upgrade.js","webpack:///./node_modules/@lwc/engine/lib/framework/utils.js","webpack:///./node_modules/@lwc/engine/lib/framework/vm.js","webpack:///./node_modules/@lwc/engine/lib/framework/watcher.js","webpack:///./node_modules/@lwc/engine/lib/framework/wc.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/aria-properties/detect.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/aria-properties/main.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/aria-properties/polyfill.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/proxy-concat/detect.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/proxy-concat/main.js","webpack:///./node_modules/@lwc/engine/lib/polyfills/proxy-concat/polyfill.js","webpack:///./node_modules/@lwc/engine/lib/shared/assert.js","webpack:///./node_modules/@lwc/engine/lib/shared/fields.js","webpack:///./node_modules/@lwc/engine/lib/shared/language.js"],"names":[],"mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACjMa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C;AACA;AACA;AACA;AACA,mHAAmH;AACnH;AACA,+B;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,OAAO,gGAAgG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AClBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,OAAO,uDAAuD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA,gC;;;;;;;;;;;;ACpBa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,mBAAmB,mBAAO,CAAC,wEAAY;AACvC,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,oDAAoD,IAAI,8CAA8C,0BAA0B;AAChI;AACA;AACA;AACA;AACA,8EAA8E,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA,SAAS;AACT;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA,kEAAkE,2BAA2B,qBAAqB,0BAA0B;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA,aAAa;AACb;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,+EAA+E,8BAA8B,OAAO,0BAA0B;AAC9I;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,6HAA6H,8BAA8B,QAAQ,0BAA0B;AAC7L;AACA;AACA,QAAQ,SAAoB;AAC5B,oHAAoH,8BAA8B,OAAO,0BAA0B;AACnL;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,uFAAuF,eAAe,QAAQ,0BAA0B,mBAAmB,EAAE,sBAAsB,eAAe;AAClM;AACA;AACA;AACA;AACA,+EAA+E,eAAe,QAAQ,0BAA0B,mBAAmB,EAAE;AACrJ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,UAAU,GAAG;AACvC;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC,4DAA4D,IAAI,OAAO,0BAA0B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,2DAA2D,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,GAAG,GAAG,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,8BAA8B;AACvD;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;ACnhBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,2GAAmC;AAC1D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AClNa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,aAAa,mBAAO,CAAC,4DAAM;AAC3B,0BAA0B,mBAAO,CAAC,sFAAmB;AACrD,mBAAmB,mBAAO,CAAC,wEAAY;AACvC;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACxHa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,0BAA0B,mBAAO,CAAC,sFAAmB;AACrD,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C,oBAAoB,mBAAO,CAAC,0EAAa;AACzC,iBAAiB,mBAAO,CAAC,yEAAkB;AAC3C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,aAAa,mBAAO,CAAC,4DAAM;AAC3B,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,cAAc,mBAAO,CAAC,6DAAY;AAClC,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C,0BAA0B,mBAAO,CAAC,sFAAmB;AACrD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA,YAAY,SAAoB;AAChC,2GAA2G,SAAS;AACpH;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,2GAA2G,SAAS;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE;AACA;AACA,oBAAoB,SAAoB;AACxC;AACA,mDAAmD,KAAK,oDAAoD,SAAS,8EAA8E,KAAK;AACxM;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE,sEAAsE,0BAA0B,oDAAoD,GAAG,GAAG,SAAS;AACnK,mGAAmG,uCAAuC;AAC1I,4HAA4H,SAAS,SAAS,SAAS,OAAO,GAAG;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,+EAA+E,6BAA6B;AAC5G,6JAA6J,6BAA6B;AAC1L;AACA;AACA,WAAW,kBAAkB,OAAO,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA,wEAAwE,uCAAuC;AAC/G;AACA;AACA,wEAAwE,uCAAuC;AAC/G;AACA,mBAAmB,gBAAgB;AACnC,sKAAsK,uCAAuC,8CAA8C,QAAQ;AACnQ;AACA,iEAAiE,QAAQ,0BAA0B,uCAAuC,oBAAoB;AAC9J;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,8DAA8D,GAAG;AACjE,kEAAkE,0BAA0B,oDAAoD,GAAG,oCAAoC,KAAK;AAC5L,kIAAkI,GAAG,cAAc,KAAK,4CAA4C,SAAS;AAC7M;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,8DAA8D,GAAG;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,sHAAsH,uCAAuC;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,sHAAsH,uCAAuC;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC;AACA,8KAA8K,uCAAuC;AACrN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,kKAAkK,uCAAuC;AACzM;AACA,eAAe,MAAM;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,qKAAqK,uCAAuC;AAC5M;AACA,eAAe,MAAM;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,yKAAyK,uCAAuC;AAChN;AACA,eAAe,MAAM;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,2KAA2K,uCAAuC;AAClN;AACA,eAAe,MAAM;AACrB;AACA,KAAK;AACL;AACA,YAAY,SAAoB;AAChC;AACA;AACA,8FAA8F,GAAG;AACjG;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,8DAA8D,GAAG;AACjE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,WAAW;AAC1B;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC,8DAA8D,GAAG;AACjE;AACA,0BAA0B,YAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,SAAoB;AACxB;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;ACtVa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,mBAAmB,mBAAO,CAAC,wEAAY;AACvC,aAAa,mBAAO,CAAC,4DAAM;AAC3B,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA,WAAW,OAAO,OAAO,GAAG;AAC5B;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,OAAO;AAClB;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,gBAAgB,SAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,kDAAkD,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,kEAAkE,GAAG,+DAA+D,OAAO;AAC3I;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,2EAA2E,GAAG;AAC9E,sFAAsF,GAAG,wCAAwC,0BAA0B;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,eAAe,wEAAwE;AACvF;AACA;AACA,qC;;;;;;;;;;;;ACvIa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACPa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,kBAAkB,mBAAO,CAAC,uEAAY;AACtC,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,uEAAY;AACtC,aAAa,mBAAO,CAAC,6DAAO;AAC5B,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,mBAAmB,mBAAO,CAAC,mFAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,wJAAwJ,8BAA8B,iBAAiB,OAAO;AAC9M;AACA,6IAA6I,8BAA8B,0BAA0B,OAAO;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE;AACA;AACA,oBAAoB,SAAoB;AACxC;AACA,mDAAmD,KAAK,oDAAoD,yBAAyB,8EAA8E,KAAK;AACxN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE,sEAAsE,0BAA0B,oDAAoD,GAAG,GAAG,yBAAyB;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,YAAY,SAAoB;AAChC,0FAA0F,yBAAyB,MAAM,KAAK,uDAAuD,yBAAyB,KAAK;AACnN;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC;AACA,kEAAkE,GAAG;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE,sEAAsE,0BAA0B,oDAAoD,GAAG,GAAG,yBAAyB;AACnL;AACA;AACA;AACA;AACA,qBAAqB,SAAoB;AACzC,yFAAyF,yBAAyB,MAAM,GAAG;AAC3H;AACA,SAAS;AACT;AACA;AACA;AACA,+B;;;;;;;;;;;;ACnHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,oC;;;;;;;;;;;;ACrCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,mBAAmB,mBAAO,CAAC,yEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AC5Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,+BAA+B,mBAAO,CAAC,2EAAQ;AAC/C,gCAAgC,mBAAO,CAAC,6EAAS;AACjD,8BAA8B,mBAAO,CAAC,yEAAO;AAC7C,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,qBAAqB,mBAAO,CAAC,6EAAe;AAC5C,mCAAmC,mBAAO,CAAC,mFAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC,uGAAuG,YAAY,2BAA2B,WAAW,gBAAgB,6BAA6B;AACtM;AACA;AACA;AACA,KAAK;AACL;AACA,oC;;;;;;;;;;;;ACtGa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,uEAAY;AACtC,kBAAkB,mBAAO,CAAC,uEAAY;AACtC,aAAa,mBAAO,CAAC,6DAAO;AAC5B,mBAAmB,mBAAO,CAAC,yEAAa;AACxC;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,SAAoB;AACpC,kEAAkE,GAAG;AACrE,sEAAsE,0BAA0B,oDAAoD,GAAG,GAAG,YAAY;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACjEa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,6EAAS;AACjC,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA,QAAQ,SAAoB;AAC5B;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AC3Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,iBAAiB,mBAAO,CAAC,yEAAkB;AAC3C,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,oBAAoB,mBAAO,CAAC,0EAAa;AACzC;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA,2EAA2E,sBAAsB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,4DAA4D,eAAe,8DAA8D,SAAS;AAClJ,6DAA6D,SAAS,gBAAgB,SAAS;AAC/F;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS,8BAA8B;AACvC;AACA,SAAS,oFAAoF;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAO,CAAC,sFAAmB;AACrD,iCAAiC,mBAAO,CAAC,oGAA0B;AACnE,8BAA8B,mBAAO,CAAC,8FAAuB;AAC7D,mBAAmB,mBAAO,CAAC,8FAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,+B;;;;;;;;;;;;AC/Ma;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,aAAa,mBAAO,CAAC,4DAAM;AAC3B,iCAAiC,mBAAO,CAAC,oFAAkB;AAC3D,gCAAgC,mBAAO,CAAC,kFAAiB;AACzD,gCAAgC,mBAAO,CAAC,kFAAiB;AACzD,8CAA8C,mBAAO,CAAC,8GAA+B;AACrF,8CAA8C,mBAAO,CAAC,8GAA+B;AACrF,4CAA4C,mBAAO,CAAC,0GAA6B;AACjF,4CAA4C,mBAAO,CAAC,0GAA6B;AACjF,kCAAkC,mBAAO,CAAC,sFAAmB;AAC7D,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,mBAAmB,mBAAO,CAAC,mGAA+B;AAC1D,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,cAAc,mBAAO,CAAC,8DAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA,WAAW,aAAa;AACxB;AACA;AACA,eAAe,QAAQ,UAAU,GAAG;AACpC,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA,QAAQ,SAAoB;AAC5B,eAAe,QAAQ,UAAU,GAAG;AACpC;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACpQa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C,eAAe,mBAAO,CAAC,2GAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,2C;;;;;;;;;;;;ACnCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,mBAAmB,mBAAO,CAAC,wEAAY;AACvC,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,aAAa,mBAAO,CAAC,4DAAM;AAC3B,6BAA6B,mBAAO,CAAC,4FAAsB;AAC3D;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,2DAA2D,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,2DAA2D,GAAG;AAC9D;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,SAAS,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAoB;AAChC,mGAAmG,WAAW,OAAO,GAAG;AACxH;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,mC;;;;;;;;;;;;AC5Ia;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAO,CAAC,qGAAgC;AACxC,mBAAO,CAAC,2GAAmC;AAC3C;AACA,gBAAgB,mBAAO,CAAC,sEAAW;AACnC;AACA,YAAY,mBAAO,CAAC,8DAAO;AAC3B;AACA;AACA;AACA,+BAA+B,mBAAO,CAAC,oGAA0B;AACjE;AACA,iBAAiB,mBAAO,CAAC,wEAAY;AACrC;AACA,iBAAiB,mBAAO,CAAC,wEAAY;AACrC;AACA,wBAAwB,mBAAO,CAAC,sFAAmB;AACnD;AACA;AACA,kBAAkB,mBAAO,CAAC,0EAAa;AACvC;AACA,iBAAiB,mBAAO,CAAC,8FAAuB;AAChD;AACA,WAAW,mBAAO,CAAC,4DAAM;AACzB;AACA,YAAY,mBAAO,CAAC,oFAAkB;AACtC;AACA,cAAc,mBAAO,CAAC,wFAAoB;AAC1C;AACA,iBAAiB,mBAAO,CAAC,8FAAuB;AAChD;AACA,aAAa,mBAAO,CAAC,sFAAmB;AACxC;AACA,iBAAiB,mBAAO,CAAC,8FAAuB;AAChD;AACA,WAAW,mBAAO,CAAC,4DAAM;AACzB;AACA,gC;;;;;;;;;;;;AC7Ca;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mBAAO,CAAC,mGAAqB;AAC3E,kBAAkB,mBAAO,CAAC,sEAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AClCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,qBAAqB,mBAAO,CAAC,6EAAe;AAC5C,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,gBAAgB,mBAAO,CAAC,mEAAU;AAClC;AACA;AACA;AACA;AACA,WAAW,QAAQ,QAAQ,GAAG;AAC9B;AACA;AACA;AACA,SAAS,QAAQ,kBAAkB,GAAG;AACtC;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa,sBAAsB,GAAG;AACjD,WAAW,QAAQ,sBAAsB,GAAG;AAC5C;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACvEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,wEAAmB;AAC7C;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,iBAAiB,mBAAO,CAAC,4EAAqB;AAC9C;AACA,WAAW,QAAQ,UAAU,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ,KAAK,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ,KAAK,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjDa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,4EAAqB;AAC9D,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,iBAAiB,mBAAO,CAAC,4EAAqB;AAC9C,gBAAgB,mBAAO,CAAC,mEAAU;AAClC,8BAA8B,mBAAO,CAAC,+FAAwB;AAC9D,qBAAqB,mBAAO,CAAC,6EAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA,kEAAkE,IAAI,gBAAgB,IAAI,2DAA2D,0CAA0C;AAC/L;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC9Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA;AACA;AACA;AACA,WAAW,aAAa,WAAW,GAAG;AACtC;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD;AACA;AACA;AACA;AACA,WAAW,aAAa,WAAW,GAAG;AACtC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC;AACA;AACA;AACA,OAAO,kDAAkD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACxEa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C;AACA;AACA;AACA;AACA,CAAC,iGAAiG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAwE,IAAI,OAAO,OAAO,MAAM;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AC1Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,aAAa,mBAAO,CAAC,4DAAM;AAC3B,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK,KAAK,KAAK;AACnC;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uDAAuD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sEAAsE,0BAA0B,oDAAoD,wBAAwB,oCAAoC,KAAK;AACrN;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+KAA+K,GAAG;AAClL;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,kLAAkL,GAAG;AACrL;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY,qBAAqB,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS,uCAAuC,SAAS;AAC7H;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,sEAAsE,0BAA0B,oDAAoD,yBAAyB,oCAAoC,KAAK;AACtN;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA,2EAA2E,UAAU;AACrF;AACA;AACA,aAAa;AACb;AACA,uBAAuB,WAAW;AAClC;AACA,4EAA4E,SAAS;AACrF;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;AC7ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AClCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,8FAA8F,QAAQ;AACtG;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA,WAAW,gCAAgC;AAC3C,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACrDa;AACb;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,yBAAyB,mBAAO,CAAC,8DAAO;AACxC,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,mCAAmC,gBAAgB;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACrHa;AACb;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,yBAAyB,mBAAO,CAAC,8DAAO;AACxC,aAAa,mBAAO,CAAC,4DAAM;AAC3B,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,0BAA0B,mBAAO,CAAC,sFAAmB;AACrD;AACA,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,6BAA6B;AACxC;AACA;AACA,+HAA+H,wCAAwC,aAAa,SAAS,OAAO,GAAG;AACvM;AACA;AACA;AACA,8EAA8E,SAAS,OAAO,GAAG;AACjG;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA,kEAAkE,GAAG,qBAAqB,SAAS;AACnG;AACA,KAAK;AACL;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,2IAA2I,0BAA0B;AACrK;AACA,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,GAAG,qEAAqE,YAAY,uCAAuC,0BAA0B;AAC5O;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,8HAA8H,YAAY;AAC1I;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AClHa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,aAAa,mBAAO,CAAC,4DAAM;AAC3B,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,iBAAiB,mBAAO,CAAC,yEAAkB;AAC3C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,cAAc,mBAAO,CAAC,8DAAO;AAC7B,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C,6BAA6B,mBAAO,CAAC,4FAAsB;AAC3D,eAAe,mBAAO,CAAC,+DAAa;AACpC;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,6BAA6B;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA,kCAAkC,kCAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mC;;;;;;;;;;;;ACtHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,iBAAiB,mBAAO,CAAC,yEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC9Da;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,cAAc,mBAAO,CAAC,8DAAO;AAC7B,oBAAoB,mBAAO,CAAC,0EAAa;AACzC,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,iBAAiB,mBAAO,CAAC,yEAAkB;AAC3C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,mBAAmB,mBAAO,CAAC,wEAAY;AACvC,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,cAAc,mBAAO,CAAC,6DAAY;AAClC,6BAA6B,mBAAO,CAAC,4FAAsB;AAC3D,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C,eAAe,mBAAO,CAAC,+DAAa;AACpC,mBAAmB,mBAAO,CAAC,mGAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,iEAAiE,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,mEAAmE,GAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,gHAAgH,IAAI;AACpH;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA,iCAAiC,SAAS,IAAI,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,oGAAoG,GAAG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,2BAA2B;AACtC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAoB;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,oBAAoB,SAAoB;AACxC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,2KAA2K,eAAe;AAC1L;AACA;AACA,wBAAwB;AACxB,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,QAAQ;AACnB;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D,sEAAsE,GAAG;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,sCAAsC;AACjD;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2CAA2C,EAAE,aAAa,GAAG,OAAO;AACvH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0JAA0J,IAAI;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA,WAAW,qBAAqB;AAChC;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,GAAG,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAoB;AAC5B,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,gCAAgC;AAChC,gBAAgB,SAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;;ACzjBa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,yEAAkB;AAC3D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C;AACA;AACA,QAAQ,SAAoB;AAC5B,gFAAgF,yBAAyB,MAAM,4BAA4B,qDAAqD,0BAA0B;AAC1N;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,oBAAoB,SAAoB;AACxC,sEAAsE,GAAG;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,4DAAM;AAC3B,oBAAoB,mBAAO,CAAC,0EAAa;AACzC,kBAAkB,mBAAO,CAAC,sEAAW;AACrC,mC;;;;;;;;;;;;AClEa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,6EAAoB;AAC/C,aAAa,mBAAO,CAAC,4DAAM;AAC3B,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,cAAc,mBAAO,CAAC,8DAAO;AAC7B,qBAAqB,mBAAO,CAAC,4EAAc;AAC3C,gBAAgB,mBAAO,CAAC,kEAAS;AACjC,uBAAuB,mBAAO,CAAC,gFAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB,SAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;;ACvFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,oFAAU;AACnC,mBAAmB,mBAAO,CAAC,wFAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACvEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,wEAAmB;AAC7C;AACA;AACA;AACA;AACA,OAAO,iBAAiB;AACxB,OAAO,yDAAyD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AC9Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AClBa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAO,CAAC,iFAAU;AACnD,mCAAmC,mBAAO,CAAC,qFAAY;AACvD;AACA;AACA;AACA,gC;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qBAAqB;AAC5B,OAAO,UAAU;AACjB,OAAO,8DAA8D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACpDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,qEAAY;AACvC,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C,eAAe,mBAAO,CAAC,+DAAa;AACpC,cAAc,mBAAO,CAAC,6DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY,GAAG,gFAAgF;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA,KAAK;AACL;AACA;AACA,iDAAiD,IAAI;AACrD;AACA,KAAK;AACL;AACA;AACA,iDAAiD,IAAI;AACrD;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,kCAAkC,QAAQ;AAC1C;AACA,qBAAqB,IAAI,IAAI,gCAAgC;AAC7D;AACA,YAAY,SAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kC;;;;;;;;;;;;AC7Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,qEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,kC;;;;;;;;;;;;AC9Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,uKAAuK;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAU;AACjB;AACA,OAAO,uKAAuK;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,4GAA4G;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oC","file":"lwc~main.app.js","sourcesContent":["\"use strict\";\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n@license\nCopyright (c) 2015 Simon Friis Vindum.\nThis code may only be used under the MIT License found at\nhttps://github.com/snabbdom/snabbdom/blob/master/LICENSE\nCode distributed by Snabbdom as part of the Snabbdom project at\nhttps://github.com/snabbdom/snabbdom/\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVNode(vnode) {\n    return vnode != null;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    const map = {};\n    let j, key, ch;\n    // TODO: simplify this by assuming that all vnodes has keys\n    for (j = beginIdx; j <= endIdx; ++j) {\n        ch = children[j];\n        if (isVNode(ch)) {\n            key = ch.key;\n            if (key !== undefined) {\n                map[key] = j;\n            }\n        }\n    }\n    return map;\n}\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        const ch = vnodes[startIdx];\n        if (isVNode(ch)) {\n            ch.hook.create(ch);\n            ch.hook.insert(ch, parentElm, before);\n        }\n    }\n}\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        const ch = vnodes[startIdx];\n        // text nodes do not have logic associated to them\n        if (isVNode(ch)) {\n            ch.hook.remove(ch, parentElm);\n        }\n    }\n}\nfunction updateDynamicChildren(parentElm, oldCh, newCh) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    let before;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!isVNode(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n        }\n        else if (!isVNode(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (!isVNode(newStartVnode)) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (!isVNode(newEndVnode)) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newStartVnode)) {\n            patchVnode(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (sameVnode(oldEndVnode, newEndVnode)) {\n            patchVnode(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            patchVnode(oldStartVnode, newEndVnode);\n            newEndVnode.hook.move(oldStartVnode, parentElm, \n            // TODO: resolve this, but using dot notation for nextSibling for now\n            oldEndVnode.elm.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            patchVnode(oldEndVnode, newStartVnode);\n            newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndef(idxInOld)) {\n                // New element\n                newStartVnode.hook.create(newStartVnode);\n                newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (isVNode(elmToMove)) {\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // New element\n                        newStartVnode.hook.create(newStartVnode);\n                        newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode);\n                        oldCh[idxInOld] = undefined;\n                        newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            const n = newCh[newEndIdx + 1];\n            before = isVNode(n) ? n.elm : null;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n        }\n        else {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n}\nexports.updateDynamicChildren = updateDynamicChildren;\nfunction updateStaticChildren(parentElm, oldCh, newCh) {\n    const { length } = newCh;\n    if (oldCh.length === 0) {\n        // the old list is empty, we can directly insert anything new\n        addVnodes(parentElm, null, newCh, 0, length);\n        return;\n    }\n    // if the old list is not empty, the new list MUST have the same\n    // amount of nodes, that's why we call this static children\n    let referenceElm = null;\n    for (let i = length - 1; i >= 0; i -= 1) {\n        const vnode = newCh[i];\n        const oldVNode = oldCh[i];\n        if (vnode !== oldVNode) {\n            if (isVNode(oldVNode)) {\n                if (isVNode(vnode)) {\n                    // both vnodes must be equivalent, and se just need to patch them\n                    patchVnode(oldVNode, vnode);\n                    referenceElm = vnode.elm;\n                }\n                else {\n                    // removing the old vnode since the new one is null\n                    oldVNode.hook.remove(oldVNode, parentElm);\n                }\n            }\n            else if (isVNode(vnode)) {\n                // this condition is unnecessary\n                vnode.hook.create(vnode);\n                // insert the new node one since the old one is null\n                vnode.hook.insert(vnode, parentElm, referenceElm);\n                referenceElm = vnode.elm;\n            }\n        }\n    }\n}\nexports.updateStaticChildren = updateStaticChildren;\nfunction patchVnode(oldVnode, vnode) {\n    if (oldVnode !== vnode) {\n        vnode.elm = oldVnode.elm;\n        vnode.hook.update(oldVnode, vnode);\n    }\n}\n//# sourceMappingURL=snabbdom.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../shared/language\");\nconst ShadowRootHostGetter = language_1.getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get;\nexports.ShadowRootHostGetter = ShadowRootHostGetter;\nconst ShadowRootInnerHTMLSetter = language_1.getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'innerHTML').set;\nexports.ShadowRootInnerHTMLSetter = ShadowRootInnerHTMLSetter;\nconst dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11\nexports.dispatchEvent = dispatchEvent;\n//# sourceMappingURL=dom.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../shared/language\");\nconst { hasAttribute, getAttribute, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, } = Element.prototype;\nexports.hasAttribute = hasAttribute;\nexports.getAttribute = getAttribute;\nexports.setAttribute = setAttribute;\nexports.setAttributeNS = setAttributeNS;\nexports.removeAttribute = removeAttribute;\nexports.removeAttributeNS = removeAttributeNS;\nconst tagNameGetter = language_1.getOwnPropertyDescriptor(Element.prototype, 'tagName').get;\nexports.tagNameGetter = tagNameGetter;\n//# sourceMappingURL=element.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../shared/language\");\nconst { appendChild, insertBefore, removeChild, replaceChild } = Node.prototype;\nexports.appendChild = appendChild;\nexports.insertBefore = insertBefore;\nexports.removeChild = removeChild;\nexports.replaceChild = replaceChild;\nconst parentNodeGetter = language_1.getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\nexports.parentNodeGetter = parentNodeGetter;\nconst parentElementGetter = language_1.hasOwnProperty.call(Node.prototype, 'parentElement')\n    ? language_1.getOwnPropertyDescriptor(Node.prototype, 'parentElement').get\n    : language_1.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11\nexports.parentElementGetter = parentElementGetter;\n//# sourceMappingURL=node.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst invoker_1 = require(\"./invoker\");\nconst language_1 = require(\"../shared/language\");\nconst utils_1 = require(\"./utils\");\nconst hooks_1 = require(\"./hooks\");\nconst patch_1 = require(\"./patch\");\nconst services_1 = require(\"./services\");\nconst restrictions_1 = require(\"./restrictions\");\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\nconst SymbolIterator = Symbol.iterator;\nconst TextHook = {\n    create: (vnode) => {\n        if (language_1.isUndefined(vnode.elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler\n            vnode.elm = document.createTextNode(vnode.text);\n        }\n        linkNodeToShadow(vnode);\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.markNodeFromVNode(vnode.elm);\n        }\n        hooks_1.createTextHook(vnode);\n    },\n    update: hooks_1.updateNodeHook,\n    insert: hooks_1.insertNodeHook,\n    move: hooks_1.insertNodeHook,\n    remove: hooks_1.removeNodeHook,\n};\nconst CommentHook = {\n    create: (vnode) => {\n        if (language_1.isUndefined(vnode.elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler\n            vnode.elm = document.createComment(vnode.text);\n        }\n        linkNodeToShadow(vnode);\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.markNodeFromVNode(vnode.elm);\n        }\n        hooks_1.createCommentHook(vnode);\n    },\n    update: hooks_1.updateNodeHook,\n    insert: hooks_1.insertNodeHook,\n    move: hooks_1.insertNodeHook,\n    remove: hooks_1.removeNodeHook,\n};\n// insert is called after update, which is used somewhere else (via a module)\n// to mark the vm as inserted, that means we cannot use update as the main channel\n// to rehydrate when dirty, because sometimes the element is not inserted just yet,\n// which breaks some invariants. For that reason, we have the following for any\n// Custom Element that is inserted via a template.\nconst ElementHook = {\n    create: (vnode) => {\n        const { data, sel, elm } = vnode;\n        const { ns } = data;\n        if (language_1.isUndefined(elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler and style tags\n            vnode.elm = language_1.isUndefined(ns)\n                ? document.createElement(sel)\n                : document.createElementNS(ns, sel);\n        }\n        linkNodeToShadow(vnode);\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.markNodeFromVNode(vnode.elm);\n        }\n        hooks_1.fallbackElmHook(vnode);\n        hooks_1.createElmHook(vnode);\n    },\n    update: (oldVnode, vnode) => {\n        hooks_1.updateElmHook(oldVnode, vnode);\n        hooks_1.updateChildrenHook(oldVnode, vnode);\n    },\n    insert: (vnode, parentNode, referenceNode) => {\n        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);\n        hooks_1.createChildrenHook(vnode);\n    },\n    move: (vnode, parentNode, referenceNode) => {\n        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);\n    },\n    remove: (vnode, parentNode) => {\n        hooks_1.removeNodeHook(vnode, parentNode);\n        hooks_1.removeElmHook(vnode);\n    },\n};\nconst CustomElementHook = {\n    create: (vnode) => {\n        const { sel, elm } = vnode;\n        if (language_1.isUndefined(elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler and style tags\n            vnode.elm = document.createElement(sel);\n        }\n        linkNodeToShadow(vnode);\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.markNodeFromVNode(vnode.elm);\n        }\n        hooks_1.createViewModelHook(vnode);\n        hooks_1.allocateChildrenHook(vnode);\n        hooks_1.createCustomElmHook(vnode);\n    },\n    update: (oldVnode, vnode) => {\n        hooks_1.updateCustomElmHook(oldVnode, vnode);\n        // in fallback mode, the allocation will always the children to\n        // empty and delegate the real allocation to the slot elements\n        hooks_1.allocateChildrenHook(vnode);\n        // in fallback mode, the children will be always empty, so, nothing\n        // will happen, but in native, it does allocate the light dom\n        hooks_1.updateChildrenHook(oldVnode, vnode);\n        // this will update the shadowRoot\n        hooks_1.rerenderCustomElmHook(vnode);\n    },\n    insert: (vnode, parentNode, referenceNode) => {\n        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);\n        hooks_1.createChildrenHook(vnode);\n        hooks_1.insertCustomElmHook(vnode);\n    },\n    move: (vnode, parentNode, referenceNode) => {\n        hooks_1.insertNodeHook(vnode, parentNode, referenceNode);\n    },\n    remove: (vnode, parentNode) => {\n        hooks_1.removeNodeHook(vnode, parentNode);\n        hooks_1.removeCustomElmHook(vnode);\n    },\n};\nfunction linkNodeToShadow(vnode) {\n    // TODO: #1164 - this should eventually be done by the polyfill directly\n    vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;\n}\n// TODO: #1136 - this should be done by the compiler, adding ns to every sub-element\nfunction addNS(vnode) {\n    const { data, children, sel } = vnode;\n    data.ns = NamespaceAttributeForSVG;\n    // TODO: #1275 - review why `sel` equal `foreignObject` should get this `ns`\n    if (language_1.isArray(children) && sel !== 'foreignObject') {\n        for (let j = 0, n = children.length; j < n; ++j) {\n            const childNode = children[j];\n            if (childNode != null && childNode.hook === ElementHook) {\n                addNS(childNode);\n            }\n        }\n    }\n}\nfunction addVNodeToChildLWC(vnode) {\n    language_1.ArrayPush.call(invoker_1.vmBeingRendered.velements, vnode);\n}\n// [h]tml node\nfunction h(sel, data, children) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isString(sel), `h() 1st argument sel must be a string.`);\n        assert_1.default.isTrue(language_1.isObject(data), `h() 2nd argument data must be an object.`);\n        assert_1.default.isTrue(language_1.isArray(children), `h() 3rd argument children must be an array.`);\n        assert_1.default.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${invoker_1.vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert_1.default.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert_1.default.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n        if (data.style && !language_1.isString(data.style)) {\n            assert_1.default.logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, invoker_1.vmBeingRendered.elm);\n        }\n        language_1.forEach.call(children, (childVnode) => {\n            if (childVnode != null) {\n                assert_1.default.isTrue(childVnode &&\n                    'sel' in childVnode &&\n                    'data' in childVnode &&\n                    'children' in childVnode &&\n                    'text' in childVnode &&\n                    'elm' in childVnode &&\n                    'key' in childVnode, `${childVnode} is not a vnode.`);\n            }\n        });\n    }\n    const { key } = data;\n    let text, elm;\n    const vnode = {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: ElementHook,\n        owner: invoker_1.vmBeingRendered,\n    };\n    if (sel.length === 3 &&\n        language_1.StringCharCodeAt.call(sel, 0) === CHAR_S &&\n        language_1.StringCharCodeAt.call(sel, 1) === CHAR_V &&\n        language_1.StringCharCodeAt.call(sel, 2) === CHAR_G) {\n        addNS(vnode);\n    }\n    return vnode;\n}\nexports.h = h;\n// [t]ab[i]ndex function\nfunction ti(value) {\n    // if value is greater than 0, we normalize to 0\n    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n    // If value is less than -1, we don't care\n    const shouldNormalize = value > 0 && !(language_1.isTrue(value) || language_1.isFalse(value));\n    if (process.env.NODE_ENV !== 'production') {\n        if (shouldNormalize) {\n            assert_1.default.logError(`Invalid tabindex value \\`${language_1.toString(value)}\\` in template for ${invoker_1.vmBeingRendered}. This attribute must be set to 0 or -1.`, invoker_1.vmBeingRendered.elm);\n        }\n    }\n    return shouldNormalize ? 0 : value;\n}\nexports.ti = ti;\n// [s]lot element node\nfunction s(slotName, data, children, slotset) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isString(slotName), `s() 1st argument slotName must be a string.`);\n        assert_1.default.isTrue(language_1.isObject(data), `s() 2nd argument data must be an object.`);\n        assert_1.default.isTrue(language_1.isArray(children), `h() 3rd argument children must be an array.`);\n    }\n    if (!language_1.isUndefined(slotset) &&\n        !language_1.isUndefined(slotset[slotName]) &&\n        slotset[slotName].length !== 0) {\n        children = slotset[slotName];\n    }\n    const vnode = h('slot', data, children);\n    if (utils_1.useSyntheticShadow) {\n        // the content of the slot has to be dynamic when in synthetic shadow mode because\n        // the `vnode.children` might be the slotted content vs default content, in which case\n        // the size and the keys are not matching.\n        patch_1.markAsDynamicChildren(children);\n    }\n    return vnode;\n}\nexports.s = s;\n// [c]ustom element node\nfunction c(sel, Ctor, data, children) {\n    if (utils_1.isCircularModuleDependency(Ctor)) {\n        Ctor = utils_1.resolveCircularModuleDependency(Ctor);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isString(sel), `c() 1st argument sel must be a string.`);\n        assert_1.default.isTrue(language_1.isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);\n        assert_1.default.isTrue(language_1.isObject(data), `c() 3nd argument data must be an object.`);\n        assert_1.default.isTrue(arguments.length === 3 || language_1.isArray(children), `c() 4nd argument data must be an array.`);\n        // checking reserved internal data properties\n        assert_1.default.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert_1.default.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n        if (data.style && !language_1.isString(data.style)) {\n            assert_1.default.logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, invoker_1.vmBeingRendered.elm);\n        }\n        if (arguments.length === 4) {\n            language_1.forEach.call(children, (childVnode) => {\n                if (childVnode != null) {\n                    assert_1.default.isTrue(childVnode &&\n                        'sel' in childVnode &&\n                        'data' in childVnode &&\n                        'children' in childVnode &&\n                        'text' in childVnode &&\n                        'elm' in childVnode &&\n                        'key' in childVnode, `${childVnode} is not a vnode.`);\n                }\n            });\n        }\n    }\n    const { key } = data;\n    let text, elm;\n    children = arguments.length === 3 ? utils_1.EmptyArray : children;\n    const vnode = {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: CustomElementHook,\n        ctor: Ctor,\n        owner: invoker_1.vmBeingRendered,\n        mode: 'open',\n    };\n    addVNodeToChildLWC(vnode);\n    return vnode;\n}\nexports.c = c;\n// [i]terable node\nfunction i(iterable, factory) {\n    const list = [];\n    // marking the list as generated from iteration so we can optimize the diffing\n    patch_1.markAsDynamicChildren(list);\n    if (language_1.isUndefined(iterable) || iterable === null) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.logError(`Invalid template iteration for value \"${language_1.toString(iterable)}\" in ${invoker_1.vmBeingRendered}. It must be an Array or an iterable Object.`, invoker_1.vmBeingRendered.elm);\n        }\n        return list;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isFalse(language_1.isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \\`${language_1.toString(iterable)}\\` in ${invoker_1.vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n    }\n    const iterator = iterable[SymbolIterator]();\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(iterator && language_1.isFunction(iterator.next), `Invalid iterator function for \"${language_1.toString(iterable)}\" in ${invoker_1.vmBeingRendered}.`);\n    }\n    let next = iterator.next();\n    let j = 0;\n    let { value, done: last } = next;\n    let keyMap;\n    let iterationError;\n    if (process.env.NODE_ENV !== 'production') {\n        keyMap = language_1.create(null);\n    }\n    while (last === false) {\n        // implementing a look-back-approach because we need to know if the element is the last\n        next = iterator.next();\n        last = next.done;\n        // template factory logic based on the previous collected value\n        const vnode = factory(value, j, j === 0, last);\n        if (language_1.isArray(vnode)) {\n            language_1.ArrayPush.apply(list, vnode);\n        }\n        else {\n            language_1.ArrayPush.call(list, vnode);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const vnodes = language_1.isArray(vnode) ? vnode : [vnode];\n            language_1.forEach.call(vnodes, (childVnode) => {\n                if (!language_1.isNull(childVnode) && language_1.isObject(childVnode) && !language_1.isUndefined(childVnode.sel)) {\n                    const { key } = childVnode;\n                    if (language_1.isString(key) || language_1.isNumber(key)) {\n                        if (keyMap[key] === 1 && language_1.isUndefined(iterationError)) {\n                            iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${invoker_1.vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n                        }\n                        keyMap[key] = 1;\n                    }\n                    else if (language_1.isUndefined(iterationError)) {\n                        iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${invoker_1.vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n                    }\n                }\n            });\n        }\n        // preparing next value\n        j += 1;\n        value = next.value;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!language_1.isUndefined(iterationError)) {\n            assert_1.default.logError(iterationError, invoker_1.vmBeingRendered.elm);\n        }\n    }\n    return list;\n}\nexports.i = i;\n/**\n * [f]lattening\n */\nfunction f(items) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isArray(items), 'flattening api can only work with arrays.');\n    }\n    const len = items.length;\n    const flattened = [];\n    // all flattened nodes should be marked as dynamic because\n    // flattened nodes are because of a conditional or iteration.\n    // We have to mark as dynamic because this could switch from an\n    // iterator to \"static\" text at any time.\n    // TODO: #1276 - compiler should give us some sort of indicator to describe whether a vnode is dynamic or not\n    patch_1.markAsDynamicChildren(flattened);\n    for (let j = 0; j < len; j += 1) {\n        const item = items[j];\n        if (language_1.isArray(item)) {\n            language_1.ArrayPush.apply(flattened, item);\n        }\n        else {\n            language_1.ArrayPush.call(flattened, item);\n        }\n    }\n    return flattened;\n}\nexports.f = f;\n// [t]ext node\nfunction t(text) {\n    const data = utils_1.EmptyObject;\n    let sel, children, key, elm;\n    return {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: TextHook,\n        owner: invoker_1.vmBeingRendered,\n    };\n}\nexports.t = t;\n// comment node\nfunction p(text) {\n    const data = utils_1.EmptyObject;\n    const sel = '!';\n    let children, key, elm;\n    return {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: CommentHook,\n        owner: invoker_1.vmBeingRendered,\n    };\n}\nexports.p = p;\n// [d]ynamic value to produce a text vnode\nfunction d(value) {\n    if (value == null) {\n        return null;\n    }\n    return t(value);\n}\nexports.d = d;\n// [b]ind function\nfunction b(fn) {\n    if (language_1.isNull(invoker_1.vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = invoker_1.vmBeingRendered;\n    return function (event) {\n        invoker_1.invokeEventListener(vm, fn, vm.component, event);\n    };\n}\nexports.b = b;\n// [f]unction_[b]ind\nfunction fb(fn) {\n    if (language_1.isNull(invoker_1.vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = invoker_1.vmBeingRendered;\n    return function () {\n        return invoker_1.invokeComponentCallback(vm, fn, language_1.ArraySlice.call(arguments));\n    };\n}\nexports.fb = fb;\n// [l]ocator_[l]istener function\nfunction ll(originalHandler, id, context) {\n    if (language_1.isNull(invoker_1.vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = invoker_1.vmBeingRendered;\n    // bind the original handler with b() so we can call it\n    // after resolving the locator\n    const eventListener = b(originalHandler);\n    // create a wrapping handler to resolve locator, and\n    // then invoke the original handler.\n    return function (event) {\n        // located service for the locator metadata\n        const { context: { locator }, } = vm;\n        if (!language_1.isUndefined(locator)) {\n            const { locator: locatorService } = services_1.Services;\n            if (locatorService) {\n                locator.resolved = {\n                    target: id,\n                    host: locator.id,\n                    targetContext: language_1.isFunction(context) && context(),\n                    hostContext: language_1.isFunction(locator.context) && locator.context(),\n                };\n                // a registered `locator` service will be invoked with\n                // access to the context.locator.resolved, which will contain:\n                // outer id, outer context, inner id, and inner context\n                services_1.invokeServiceHook(vm, locatorService);\n            }\n        }\n        // invoke original event listener via b()\n        eventListener(event);\n    };\n}\nexports.ll = ll;\n// [k]ey function\nfunction k(compilerKey, obj) {\n    switch (typeof obj) {\n        case 'number':\n        case 'string':\n            return compilerKey + ':' + obj;\n        case 'object':\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.fail(`Invalid key value \"${obj}\" in ${invoker_1.vmBeingRendered}. Key must be a string or number.`);\n            }\n    }\n}\nexports.k = k;\n// [g]lobal [id] function\nfunction gid(id) {\n    if (language_1.isUndefined(id) || id === '') {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, invoker_1.vmBeingRendered.elm);\n        }\n        return id;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (language_1.isNull(id)) {\n        return null;\n    }\n    return `${id}-${invoker_1.vmBeingRendered.idx}`;\n}\nexports.gid = gid;\n// [f]ragment [id] function\nfunction fid(url) {\n    if (language_1.isUndefined(url) || url === '') {\n        if (process.env.NODE_ENV !== 'production') {\n            if (language_1.isUndefined(url)) {\n                assert_1.default.logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, invoker_1.vmBeingRendered.elm);\n            }\n        }\n        return url;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (language_1.isNull(url)) {\n        return null;\n    }\n    // Apply transformation only for fragment-only-urls\n    if (/^#/.test(url)) {\n        return `${url}-${invoker_1.vmBeingRendered.idx}`;\n    }\n    return url;\n}\nexports.fid = fid;\n//# sourceMappingURL=api.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst main_1 = require(\"../polyfills/aria-properties/main\");\nconst language_1 = require(\"../shared/language\");\n// These properties get added to LWCElement.prototype publicProps automatically\nexports.defaultDefHTMLPropertyNames = [\n    'dir',\n    'id',\n    'accessKey',\n    'title',\n    'lang',\n    'hidden',\n    'draggable',\n    'tabIndex',\n];\n// Few more exceptions that are using the attribute name to match the property in lowercase.\n// this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx\n// and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n// Note: this list most be in sync with the compiler as well.\nconst HTMLPropertyNamesWithLowercasedReflectiveAttributes = [\n    'accessKey',\n    'readOnly',\n    'tabIndex',\n    'bgColor',\n    'colSpan',\n    'rowSpan',\n    'contentEditable',\n    'dateTime',\n    'formAction',\n    'isMap',\n    'maxLength',\n    'useMap',\n];\nfunction offsetPropertyErrorMessage(name) {\n    return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n}\n// Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\nexports.globalHTMLProperties = language_1.assign(language_1.create(null), {\n    id: {\n        attribute: 'id',\n    },\n    accessKey: {\n        attribute: 'accesskey',\n    },\n    accessKeyLabel: {\n        readOnly: true,\n    },\n    className: {\n        attribute: 'class',\n        error: `Using the \\`className\\` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the \\`classList\\` API instead.`,\n    },\n    contentEditable: {\n        attribute: 'contenteditable',\n    },\n    isContentEditable: {\n        readOnly: true,\n    },\n    contextMenu: {\n        attribute: 'contextmenu',\n    },\n    dataset: {\n        readOnly: true,\n        error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\",\n    },\n    dir: {\n        attribute: 'dir',\n    },\n    draggable: {\n        attribute: 'draggable',\n    },\n    dropzone: {\n        attribute: 'dropzone',\n        readOnly: true,\n    },\n    hidden: {\n        attribute: 'hidden',\n    },\n    itemScope: {\n        attribute: 'itemscope',\n    },\n    itemType: {\n        attribute: 'itemtype',\n        readOnly: true,\n    },\n    itemId: {\n        attribute: 'itemid',\n    },\n    itemRef: {\n        attribute: 'itemref',\n        readOnly: true,\n    },\n    itemProp: {\n        attribute: 'itemprop',\n        readOnly: true,\n    },\n    lang: {\n        attribute: 'lang',\n    },\n    offsetHeight: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetHeight'),\n    },\n    offsetLeft: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetLeft'),\n    },\n    offsetParent: {\n        readOnly: true,\n    },\n    offsetTop: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetTop'),\n    },\n    offsetWidth: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetWidth'),\n    },\n    properties: {\n        readOnly: true,\n    },\n    spellcheck: {\n        attribute: 'spellcheck',\n    },\n    style: {\n        attribute: 'style',\n    },\n    tabIndex: {\n        attribute: 'tabindex',\n    },\n    title: {\n        attribute: 'title',\n    },\n    // additional global attributes that are not present in the link above.\n    role: {\n        attribute: 'role',\n    },\n    slot: {\n        attribute: 'slot',\n        error: 'Using the `slot` attribute is an anti-pattern.',\n    },\n});\nconst AttrNameToPropNameMap = language_1.create(null);\nconst PropNameToAttrNameMap = language_1.create(null);\n// Synthetic creation of all AOM property descriptors for Custom Elements\nlanguage_1.forEach.call(main_1.ElementPrototypeAriaPropertyNames, (propName) => {\n    // Typescript is inferring the wrong function type for this particular\n    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n    // @ts-ignore type-mismatch\n    const attrName = language_1.StringToLowerCase.call(language_1.StringReplace.call(propName, /^aria/, 'aria-'));\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nlanguage_1.forEach.call(exports.defaultDefHTMLPropertyNames, propName => {\n    const attrName = language_1.StringToLowerCase.call(propName);\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nlanguage_1.forEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, propName => {\n    const attrName = language_1.StringToLowerCase.call(propName);\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nconst CAMEL_REGEX = /-([a-z])/g;\n/**\n * This method maps between attribute names\n * and the corresponding property name.\n */\nfunction getPropNameFromAttrName(attrName) {\n    if (language_1.isUndefined(AttrNameToPropNameMap[attrName])) {\n        AttrNameToPropNameMap[attrName] = language_1.StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());\n    }\n    return AttrNameToPropNameMap[attrName];\n}\nexports.getPropNameFromAttrName = getPropNameFromAttrName;\nconst CAPS_REGEX = /[A-Z]/g;\n/**\n * This method maps between property names\n * and the corresponding attribute name.\n */\nfunction getAttrNameFromPropName(propName) {\n    if (language_1.isUndefined(PropNameToAttrNameMap[propName])) {\n        PropNameToAttrNameMap[propName] = language_1.StringReplace.call(propName, CAPS_REGEX, (match) => '-' + match.toLowerCase());\n    }\n    return PropNameToAttrNameMap[propName];\n}\nexports.getAttrNameFromPropName = getAttrNameFromPropName;\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n    return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nexports.isAttributeLocked = isAttributeLocked;\nfunction lockAttribute(_elm, _key) {\n    controlledElement = null;\n    controlledAttributeName = undefined;\n}\nexports.lockAttribute = lockAttribute;\nfunction unlockAttribute(elm, key) {\n    controlledElement = elm;\n    controlledAttributeName = key;\n}\nexports.unlockAttribute = unlockAttribute;\n//# sourceMappingURL=attributes.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for creating the base bridge class BaseBridgeElement\n * that represents the HTMLElement extension used for any LWC inserted in the DOM.\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst vm_1 = require(\"./vm\");\nconst html_properties_1 = require(\"./html-properties\");\nconst membrane_1 = require(\"./membrane\");\nfunction prepareForPropUpdate(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n}\nexports.prepareForPropUpdate = prepareForPropUpdate;\n// A bridge descriptor is a descriptor whose job is just to get the component instance\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\nconst cachedGetterByKey = language_1.create(null);\nconst cachedSetterByKey = language_1.create(null);\nfunction createGetter(key) {\n    let fn = cachedGetterByKey[key];\n    if (language_1.isUndefined(fn)) {\n        fn = cachedGetterByKey[key] = function () {\n            const vm = vm_1.getCustomElementVM(this);\n            const { getHook } = vm;\n            return getHook(vm.component, key);\n        };\n    }\n    return fn;\n}\nfunction createSetter(key) {\n    let fn = cachedSetterByKey[key];\n    if (language_1.isUndefined(fn)) {\n        fn = cachedSetterByKey[key] = function (newValue) {\n            const vm = vm_1.getCustomElementVM(this);\n            const { setHook } = vm;\n            newValue = membrane_1.reactiveMembrane.getReadOnlyProxy(newValue);\n            setHook(vm.component, key, newValue);\n        };\n    }\n    return fn;\n}\nfunction createMethodCaller(methodName) {\n    return function () {\n        const vm = vm_1.getCustomElementVM(this);\n        const { callHook, component } = vm;\n        const fn = component[methodName];\n        return callHook(vm.component, fn, language_1.ArraySlice.call(arguments));\n    };\n}\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n    let HTMLBridgeElement;\n    /**\n     * Modern browsers will have all Native Constructors as regular Classes\n     * and must be instantiated with the new keyword. In older browsers,\n     * specifically IE11, those are objects with a prototype property defined,\n     * since they are not supposed to be extended or instantiated with the\n     * new keyword. This forking logic supports both cases, specifically because\n     * wc.ts relies on the construction path of the bridges to create new\n     * fully qualifying web components.\n     */\n    if (language_1.isFunction(SuperClass)) {\n        HTMLBridgeElement = class extends SuperClass {\n        };\n    }\n    else {\n        HTMLBridgeElement = function () {\n            // Bridge classes are not supposed to be instantiated directly in\n            // browsers that do not support web components.\n            throw new TypeError('Illegal constructor');\n        };\n        // prototype inheritance dance\n        language_1.setPrototypeOf(HTMLBridgeElement, SuperClass);\n        language_1.setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n        language_1.defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n            writable: true,\n            configurable: true,\n            value: HTMLBridgeElement,\n        });\n    }\n    const descriptors = language_1.create(null);\n    // expose getters and setters for each public props on the new Element Bridge\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        descriptors[propName] = {\n            get: createGetter(propName),\n            set: createSetter(propName),\n            enumerable: true,\n            configurable: true,\n        };\n    }\n    // expose public methods as props on the new Element Bridge\n    for (let i = 0, len = methods.length; i < len; i += 1) {\n        const methodName = methods[i];\n        descriptors[methodName] = {\n            value: createMethodCaller(methodName),\n            writable: true,\n            configurable: true,\n        };\n    }\n    language_1.defineProperties(HTMLBridgeElement.prototype, descriptors);\n    return HTMLBridgeElement;\n}\nexports.HTMLBridgeElementFactory = HTMLBridgeElementFactory;\nexports.BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), []);\nlanguage_1.freeze(exports.BaseBridgeElement);\nlanguage_1.seal(exports.BaseBridgeElement.prototype);\n//# sourceMappingURL=base-bridge-element.js.map","\"use strict\";\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for producing the ComponentDef object that is always\n * accessible via `vm.def`. This is lazily created during the creation of the first\n * instance of a component class, and shared across all instances.\n *\n * This structure can be used to synthetically create proxies, and understand the\n * shape of a component. It is also used internally to apply extra optimizations.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst html_properties_1 = require(\"./html-properties\");\nconst restrictions_1 = require(\"./restrictions\");\nconst component_1 = require(\"./component\");\nconst fields_1 = require(\"../shared/fields\");\nconst utils_1 = require(\"./utils\");\nconst invoker_1 = require(\"./invoker\");\nconst vm_1 = require(\"./vm\");\nconst watcher_1 = require(\"./watcher\");\nconst dom_1 = require(\"../env/dom\");\nconst restrictions_2 = require(\"./restrictions\");\nconst attributes_1 = require(\"./attributes\");\nconst secure_template_1 = require(\"./secure-template\");\nconst GlobalEvent = Event; // caching global reference to avoid poisoning\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!language_1.isFunction(get)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n        }\n        throw new TypeError();\n    }\n    if (!language_1.isFunction(set)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        enumerable,\n        configurable,\n        get() {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n            }\n            if (invoker_1.isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    const name = vm.elm.constructor.name;\n                    assert_1.default.logError(`\\`${name}\\` constructor can't read the value of property \\`${propName}\\` because the owner component hasn't set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm.elm);\n                }\n                return;\n            }\n            watcher_1.observeMutation(this, propName);\n            return get.call(vm.elm);\n        },\n        set(newValue) {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);\n                assert_1.default.invariant(!language_1.isObject(newValue) || language_1.isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n            }\n            if (newValue !== vm.cmpProps[propName]) {\n                vm.cmpProps[propName] = newValue;\n                if (language_1.isFalse(vm.isDirty)) {\n                    // perf optimization to skip this step if not in the DOM\n                    watcher_1.notifyMutation(this, propName);\n                }\n            }\n            return set.call(vm.elm, newValue);\n        },\n    };\n}\nfunction getLinkedElement(cmp) {\n    return vm_1.getComponentVM(cmp).elm;\n}\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\nfunction BaseLightningElement() {\n    // This should be as performant as possible, while any initialization should be done lazily\n    if (language_1.isNull(invoker_1.vmBeingConstructed)) {\n        throw new ReferenceError();\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue('cmpProps' in invoker_1.vmBeingConstructed, `${invoker_1.vmBeingConstructed} is not a vm.`);\n        assert_1.default.invariant(invoker_1.vmBeingConstructed.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${invoker_1.vmBeingConstructed}.`);\n    }\n    const vm = invoker_1.vmBeingConstructed;\n    const { elm, mode, def: { ctor }, } = vm;\n    const component = this;\n    vm.component = component;\n    // interaction hooks\n    // We are intentionally hiding this argument from the formal API of LWCElement because\n    // we don't want folks to know about it just yet.\n    if (arguments.length === 1) {\n        const { callHook, setHook, getHook } = arguments[0];\n        vm.callHook = callHook;\n        vm.setHook = setHook;\n        vm.getHook = getHook;\n    }\n    // attaching the shadowRoot\n    const shadowRootOptions = {\n        mode,\n        delegatesFocus: !!ctor.delegatesFocus,\n    };\n    const cmpRoot = elm.attachShadow(shadowRootOptions);\n    // linking elm, shadow root and component with the VM\n    fields_1.setHiddenField(component, utils_1.ViewModelReflection, vm);\n    fields_1.setInternalField(elm, utils_1.ViewModelReflection, vm);\n    fields_1.setInternalField(cmpRoot, utils_1.ViewModelReflection, vm);\n    // VM is now initialized\n    vm.cmpRoot = cmpRoot;\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_2.patchComponentWithRestrictions(component);\n        restrictions_2.patchShadowRootWithRestrictions(cmpRoot, utils_1.EmptyObject);\n    }\n}\nexports.BaseLightningElement = BaseLightningElement;\n// HTML Element - The Good Parts\nBaseLightningElement.prototype = {\n    constructor: BaseLightningElement,\n    dispatchEvent(event) {\n        const elm = getLinkedElement(this);\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            if (arguments.length === 0) {\n                throw new Error(`Failed to execute 'dispatchEvent' on ${component_1.getComponentAsString(this)}: 1 argument required, but only 0 present.`);\n            }\n            if (!(event instanceof GlobalEvent)) {\n                throw new Error(`Failed to execute 'dispatchEvent' on ${component_1.getComponentAsString(this)}: parameter 1 is not of type 'Event'.`);\n            }\n            const { type: evtName } = event;\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no one is listening for the event \"${evtName}\" just yet.`);\n            if (!/^[a-z][a-z0-9_]*$/.test(evtName)) {\n                assert_1.default.logError(`Invalid event type \"${evtName}\" dispatched in element ${component_1.getComponentAsString(this)}. Event name must ${[\n                    '1) Start with a lowercase letter',\n                    '2) Contain only lowercase letters, numbers, and underscores',\n                ].join(' ')}`, elm);\n            }\n        }\n        return dom_1.dispatchEvent.call(elm, event);\n    },\n    addEventListener(type, listener, options) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n            assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert_1.default.invariant(language_1.isFunction(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n        const wrappedListener = component_1.getWrappedComponentsListener(vm, listener);\n        vm.elm.addEventListener(type, wrappedListener, options);\n    },\n    removeEventListener(type, listener, options) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        }\n        const wrappedListener = component_1.getWrappedComponentsListener(vm, listener);\n        vm.elm.removeEventListener(type, wrappedListener, options);\n    },\n    setAttributeNS(ns, attrName, _value) {\n        const elm = getLinkedElement(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm_1.getComponentVM(this)), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);\n        }\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        elm.setAttributeNS.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n    },\n    removeAttributeNS(ns, attrName) {\n        const elm = getLinkedElement(this);\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        elm.removeAttributeNS.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n    },\n    removeAttribute(attrName) {\n        const elm = getLinkedElement(this);\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        elm.removeAttribute.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n    },\n    setAttribute(attrName, _value) {\n        const elm = getLinkedElement(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm_1.getComponentVM(this)), `Failed to construct '${component_1.getComponentAsString(this)}': The result must not have attributes.`);\n        }\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        elm.setAttribute.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n    },\n    getAttribute(attrName) {\n        const elm = getLinkedElement(this);\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        const value = elm.getAttribute.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n        return value;\n    },\n    getAttributeNS(ns, attrName) {\n        const elm = getLinkedElement(this);\n        attributes_1.unlockAttribute(elm, attrName);\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        const value = elm.getAttributeNS.apply(elm, arguments);\n        attributes_1.lockAttribute(elm, attrName);\n        return value;\n    },\n    getBoundingClientRect() {\n        const elm = getLinkedElement(this);\n        if (process.env.NODE_ENV !== 'production') {\n            const vm = vm_1.getComponentVM(this);\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n        }\n        return elm.getBoundingClientRect();\n    },\n    /**\n     * Returns the first element that is a descendant of node that\n     * matches selectors.\n     */\n    // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n    // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n    querySelector(selectors) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.querySelector(selectors);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match selectors.\n     */\n    // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,\n    // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,\n    querySelectorAll(selectors) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.querySelectorAll(selectors);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match the provided tagName.\n     */\n    getElementsByTagName(tagNameOrWildCard) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.getElementsByTagName(tagNameOrWildCard);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match the provide classnames.\n     */\n    getElementsByClassName(names) {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${component_1.getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.getElementsByClassName(names);\n    },\n    get classList() {\n        if (process.env.NODE_ENV !== 'production') {\n            const vm = vm_1.getComponentVM(this);\n            // TODO: #1290 - this still fails in dev but works in production, eventually, we should just throw in all modes\n            assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n        }\n        return getLinkedElement(this).classList;\n    },\n    get template() {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        }\n        return vm.cmpRoot;\n    },\n    get shadowRoot() {\n        // From within the component instance, the shadowRoot is always\n        // reported as \"closed\". Authors should rely on this.template instead.\n        return null;\n    },\n    render() {\n        const vm = vm_1.getComponentVM(this);\n        const { template } = vm.def;\n        return language_1.isUndefined(template) ? secure_template_1.defaultEmptyTemplate : template;\n    },\n    toString() {\n        const vm = vm_1.getComponentVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        }\n        return `[object ${vm.def.name}]`;\n    },\n};\n// Typescript is inferring the wrong function type for this particular\n// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n// @ts-ignore type-mismatch\nconst baseDescriptors = language_1.ArrayReduce.call(language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), (descriptors, propName) => {\n    descriptors[propName] = createBridgeToElementDescriptor(propName, html_properties_1.HTMLElementOriginalDescriptors[propName]);\n    return descriptors;\n}, language_1.create(null));\nlanguage_1.defineProperties(BaseLightningElement.prototype, baseDescriptors);\nif (process.env.NODE_ENV !== 'production') {\n    restrictions_1.patchLightningElementPrototypeWithRestrictions(BaseLightningElement.prototype);\n}\nlanguage_1.freeze(BaseLightningElement);\nlanguage_1.seal(BaseLightningElement.prototype);\n//# sourceMappingURL=base-lightning-element.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst invoker_1 = require(\"./invoker\");\nconst language_1 = require(\"../shared/language\");\nconst services_1 = require(\"./services\");\nconst vm_1 = require(\"./vm\");\nconst element_1 = require(\"../env/element\");\nconst signedComponentToMetaMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerComponent(Ctor, { name, tmpl: template }) {\n    signedComponentToMetaMap.set(Ctor, { name, template });\n    // chaining this method as a way to wrap existing\n    // assignment of component constructor easily, without too much transformation\n    return Ctor;\n}\nexports.registerComponent = registerComponent;\nfunction getComponentRegisteredMeta(Ctor) {\n    return signedComponentToMetaMap.get(Ctor);\n}\nexports.getComponentRegisteredMeta = getComponentRegisteredMeta;\nfunction createComponent(uninitializedVm, Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(uninitializedVm && 'cmpProps' in uninitializedVm, `${uninitializedVm} is not a vm.`);\n    }\n    // create the component instance\n    invoker_1.invokeComponentConstructor(uninitializedVm, Ctor);\n    const initializedVm = uninitializedVm;\n    if (language_1.isUndefined(initializedVm.component)) {\n        throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);\n    }\n}\nexports.createComponent = createComponent;\nfunction linkComponent(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    // wiring service\n    const { def: { wire }, } = vm;\n    if (wire) {\n        const { wiring } = services_1.Services;\n        if (wiring) {\n            services_1.invokeServiceHook(vm, wiring);\n        }\n    }\n}\nexports.linkComponent = linkComponent;\nfunction clearReactiveListeners(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { deps } = vm;\n    const len = deps.length;\n    if (len > 0) {\n        for (let i = 0; i < len; i += 1) {\n            const set = deps[i];\n            const pos = language_1.ArrayIndexOf.call(deps[i], vm);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.invariant(pos > -1, `when clearing up deps, the vm must be part of the collection.`);\n            }\n            language_1.ArraySplice.call(set, pos, 1);\n        }\n        deps.length = 0;\n    }\n}\nexports.clearReactiveListeners = clearReactiveListeners;\nfunction clearChildLWC(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    vm.velements = [];\n}\nfunction renderComponent(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.invariant(vm.isDirty, `${vm} is not dirty.`);\n    }\n    clearReactiveListeners(vm);\n    clearChildLWC(vm);\n    const vnodes = invoker_1.invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    vm.isScheduled = false;\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(language_1.isArray(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n    }\n    return vnodes;\n}\nexports.renderComponent = renderComponent;\nfunction markComponentAsDirty(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n        assert_1.default.isFalse(invoker_1.isRendering, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${invoker_1.vmBeingRendered}.`);\n    }\n    vm.isDirty = true;\n}\nexports.markComponentAsDirty = markComponentAsDirty;\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    if (!language_1.isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let wrappedListener = cmpEventListenerMap.get(listener);\n    if (language_1.isUndefined(wrappedListener)) {\n        wrappedListener = function (event) {\n            invoker_1.invokeEventListener(vm, listener, undefined, event);\n        };\n        cmpEventListenerMap.set(listener, wrappedListener);\n    }\n    return wrappedListener;\n}\nexports.getWrappedComponentsListener = getWrappedComponentsListener;\nfunction getComponentAsString(component) {\n    if (process.env.NODE_ENV === 'production') {\n        throw new ReferenceError();\n    }\n    const vm = vm_1.getComponentVM(component);\n    return `<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(vm.elm))}>`;\n}\nexports.getComponentAsString = getComponentAsString;\n//# sourceMappingURL=component.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.currentContext = {};\nfunction establishContext(ctx) {\n    exports.currentContext = ctx;\n}\nexports.establishContext = establishContext;\n//# sourceMappingURL=context.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst invoker_1 = require(\"../invoker\");\nconst language_1 = require(\"../../shared/language\");\nconst watcher_1 = require(\"../watcher\");\nconst vm_1 = require(\"../vm\");\nconst language_2 = require(\"../../shared/language\");\nconst register_1 = require(\"./register\");\n/**\n * @api decorator to mark public fields and public methods in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\nfunction api(target, propName, descriptor) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (arguments.length !== 3) {\n            assert_1.default.fail(`@api decorator can only be used as a decorator function.`);\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(!descriptor || (language_2.isFunction(descriptor.get) || language_2.isFunction(descriptor.set)), `Invalid property ${language_1.toString(propName)} definition in ${target}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`);\n        if (language_1.isObject(descriptor) && language_2.isFunction(descriptor.set)) {\n            assert_1.default.isTrue(language_1.isObject(descriptor) && language_2.isFunction(descriptor.get), `Missing getter for property ${language_1.toString(propName)} decorated with @api in ${target}. You cannot have a setter without the corresponding getter.`);\n        }\n    }\n    const meta = register_1.getDecoratorsRegisteredMeta(target);\n    // initializing getters and setters for each public prop on the target prototype\n    if (language_1.isObject(descriptor) && (language_2.isFunction(descriptor.get) || language_2.isFunction(descriptor.set))) {\n        // if it is configured as an accessor it must have a descriptor\n        // @ts-ignore it must always be set before calling this method\n        meta.props[propName].config = language_2.isFunction(descriptor.set) ? 3 : 1;\n        return createPublicAccessorDescriptor(target, propName, descriptor);\n    }\n    else {\n        // @ts-ignore it must always be set before calling this method\n        meta.props[propName].config = 0;\n        return createPublicPropertyDescriptor(target, propName, descriptor);\n    }\n}\nexports.default = api;\nfunction createPublicPropertyDescriptor(proto, key, descriptor) {\n    return {\n        get() {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n            }\n            if (invoker_1.isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    const name = vm.elm.constructor.name;\n                    assert_1.default.logError(`\\`${name}\\` constructor can’t read the value of property \\`${language_1.toString(key)}\\` because the owner component hasn’t set the value yet. Instead, use the \\`${name}\\` constructor to set a default value for the property.`, vm.elm);\n                }\n                return;\n            }\n            watcher_1.observeMutation(this, key);\n            return vm.cmpProps[key];\n        },\n        set(newValue) {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${language_1.toString(key)}`);\n            }\n            vm.cmpProps[key] = newValue;\n            // avoid notification of observability if the instance is already dirty\n            if (language_1.isFalse(vm.isDirty)) {\n                // perf optimization to skip this step if the component is dirty already.\n                watcher_1.notifyMutation(this, key);\n            }\n        },\n        enumerable: language_2.isUndefined(descriptor) ? true : descriptor.enumerable,\n    };\n}\nfunction createPublicAccessorDescriptor(Ctor, key, descriptor) {\n    const { get, set, enumerable } = descriptor;\n    if (!language_2.isFunction(get)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.fail(`Invalid attempt to create public property descriptor ${language_1.toString(key)} in ${Ctor}. It is missing the getter declaration with @api get ${language_1.toString(key)}() {} syntax.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        get() {\n            if (process.env.NODE_ENV !== 'production') {\n                const vm = vm_1.getComponentVM(this);\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n            }\n            return get.call(this);\n        },\n        set(newValue) {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${language_1.toString(key)}`);\n            }\n            if (set) {\n                set.call(this, newValue);\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.fail(`Invalid attempt to set a new value for property ${language_1.toString(key)} of ${vm} that does not has a setter decorated with @api.`);\n            }\n        },\n        enumerable,\n    };\n}\n//# sourceMappingURL=api.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\" in\n * LWC by exposing hooks into the component life-cycle. This API is subject\n * to change or being removed.\n */\nfunction decorate(Ctor, decorators) {\n    // intentionally comparing decorators with null and undefined\n    if (!language_1.isFunction(Ctor) || decorators == null) {\n        throw new TypeError();\n    }\n    const props = language_1.getOwnPropertyNames(decorators);\n    // intentionally allowing decoration of classes only for now\n    const target = Ctor.prototype;\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        const decorator = decorators[propName];\n        if (!language_1.isFunction(decorator)) {\n            throw new TypeError();\n        }\n        const originalDescriptor = language_1.getOwnPropertyDescriptor(target, propName);\n        const descriptor = decorator(Ctor, propName, originalDescriptor);\n        if (!language_1.isUndefined(descriptor)) {\n            language_1.defineProperty(target, propName, descriptor);\n        }\n    }\n    return Ctor; // chaining\n}\nexports.default = decorate;\n//# sourceMappingURL=decorate.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst membrane_1 = require(\"../membrane\");\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\nfunction readonly(obj) {\n    if (process.env.NODE_ENV !== 'production') {\n        // TODO: #1292 - Remove the readonly decorator\n        if (arguments.length !== 1) {\n            assert_1.default.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n        }\n    }\n    return membrane_1.reactiveMembrane.getReadOnlyProxy(obj);\n}\nexports.default = readonly;\n//# sourceMappingURL=readonly.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst language_1 = require(\"../../shared/language\");\nconst wire_1 = __importDefault(require(\"./wire\"));\nconst track_1 = __importDefault(require(\"./track\"));\nconst api_1 = __importDefault(require(\"./api\"));\nconst utils_1 = require(\"../utils\");\nconst attributes_1 = require(\"../attributes\");\nconst decorate_1 = __importDefault(require(\"./decorate\"));\nconst signedDecoratorToMetaMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerDecorators(Ctor, meta) {\n    const decoratorMap = language_1.create(null);\n    const props = getPublicPropertiesHash(Ctor, meta.publicProps);\n    const methods = getPublicMethodsHash(Ctor, meta.publicMethods);\n    const wire = getWireHash(Ctor, meta.wire);\n    const track = getTrackHash(Ctor, meta.track);\n    signedDecoratorToMetaMap.set(Ctor, {\n        props,\n        methods,\n        wire,\n        track,\n    });\n    for (const propName in props) {\n        decoratorMap[propName] = api_1.default;\n    }\n    if (wire) {\n        for (const propName in wire) {\n            const wireDef = wire[propName];\n            if (wireDef.method) {\n                // for decorated methods we need to do nothing\n                continue;\n            }\n            decoratorMap[propName] = wire_1.default(wireDef.adapter, wireDef.params);\n        }\n    }\n    if (track) {\n        for (const propName in track) {\n            decoratorMap[propName] = track_1.default;\n        }\n    }\n    decorate_1.default(Ctor, decoratorMap);\n    return Ctor;\n}\nexports.registerDecorators = registerDecorators;\nfunction getDecoratorsRegisteredMeta(Ctor) {\n    return signedDecoratorToMetaMap.get(Ctor);\n}\nexports.getDecoratorsRegisteredMeta = getDecoratorsRegisteredMeta;\nfunction getTrackHash(target, track) {\n    if (language_1.isUndefined(track) || language_1.getOwnPropertyNames(track).length === 0) {\n        return utils_1.EmptyObject;\n    }\n    // TODO: #1302 - check that anything in `track` is correctly defined in the prototype\n    return language_1.assign(language_1.create(null), track);\n}\nfunction getWireHash(target, wire) {\n    if (language_1.isUndefined(wire) || language_1.getOwnPropertyNames(wire).length === 0) {\n        return;\n    }\n    // TODO: #1302 - check that anything in `wire` is correctly defined in the prototype\n    return language_1.assign(language_1.create(null), wire);\n}\nfunction getPublicPropertiesHash(target, props) {\n    if (language_1.isUndefined(props) || language_1.getOwnPropertyNames(props).length === 0) {\n        return utils_1.EmptyObject;\n    }\n    return language_1.getOwnPropertyNames(props).reduce((propsHash, propName) => {\n        const attr = attributes_1.getAttrNameFromPropName(propName);\n        propsHash[propName] = language_1.assign({\n            config: 0,\n            type: 'any',\n            attr,\n        }, props[propName]);\n        return propsHash;\n    }, language_1.create(null));\n}\nfunction getPublicMethodsHash(target, publicMethods) {\n    if (language_1.isUndefined(publicMethods) || publicMethods.length === 0) {\n        return utils_1.EmptyObject;\n    }\n    return publicMethods.reduce((methodsHash, methodName) => {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(language_1.isFunction(target.prototype[methodName]), `Component \"${target.name}\" should have a method \\`${methodName}\\` instead of ${target.prototype[methodName]}.`);\n        }\n        methodsHash[methodName] = target.prototype[methodName];\n        return methodsHash;\n    }, language_1.create(null));\n}\n//# sourceMappingURL=register.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst language_1 = require(\"../../shared/language\");\nconst invoker_1 = require(\"../invoker\");\nconst watcher_1 = require(\"../watcher\");\nconst vm_1 = require(\"../vm\");\nconst membrane_1 = require(\"../membrane\");\nfunction track(target, prop, descriptor) {\n    if (arguments.length === 1) {\n        return membrane_1.reactiveMembrane.getProxy(target);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (arguments.length !== 3) {\n            assert_1.default.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n        }\n        if (!language_1.isUndefined(descriptor)) {\n            const { get, set, configurable, writable } = descriptor;\n            assert_1.default.isTrue(!get && !set, `Compiler Error: A @track decorator can only be applied to a public field.`);\n            assert_1.default.isTrue(configurable !== false, `Compiler Error: A @track decorator can only be applied to a configurable property.`);\n            assert_1.default.isTrue(writable !== false, `Compiler Error: A @track decorator can only be applied to a writable property.`);\n        }\n    }\n    return createTrackedPropertyDescriptor(target, prop, language_1.isUndefined(descriptor) ? true : descriptor.enumerable === true);\n}\nexports.default = track;\nfunction createTrackedPropertyDescriptor(Ctor, key, enumerable) {\n    return {\n        get() {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n            }\n            watcher_1.observeMutation(this, key);\n            return vm.cmpTrack[key];\n        },\n        set(newValue) {\n            const vm = vm_1.getComponentVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${vm}.${String(key)}`);\n            }\n            const reactiveOrAnyValue = membrane_1.reactiveMembrane.getProxy(newValue);\n            if (reactiveOrAnyValue !== vm.cmpTrack[key]) {\n                vm.cmpTrack[key] = reactiveOrAnyValue;\n                if (language_1.isFalse(vm.isDirty)) {\n                    // perf optimization to skip this step if the track property is on a component that is already dirty\n                    watcher_1.notifyMutation(this, key);\n                }\n            }\n        },\n        enumerable,\n        configurable: true,\n    };\n}\nexports.createTrackedPropertyDescriptor = createTrackedPropertyDescriptor;\n//# sourceMappingURL=track.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst track_1 = require(\"./track\");\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst language_1 = require(\"../../shared/language\");\nfunction wireDecorator(target, prop, descriptor) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!language_1.isUndefined(descriptor)) {\n            const { get, set, configurable, writable } = descriptor;\n            assert_1.default.isTrue(!get && !set, `Compiler Error: A @wire decorator can only be applied to a public field.`);\n            assert_1.default.isTrue(configurable !== false, `Compiler Error: A @wire decorator can only be applied to a configurable property.`);\n            assert_1.default.isTrue(writable !== false, `Compiler Error: A @wire decorator can only be applied to a writable property.`);\n        }\n    }\n    return track_1.createTrackedPropertyDescriptor(target, prop, language_1.isObject(descriptor) ? descriptor.enumerable === true : true);\n}\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\nfunction wire(_adapter, _config) {\n    const len = arguments.length;\n    if (len > 0 && len < 3) {\n        return wireDecorator;\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.fail('@wire(adapter, config?) may only be used as a decorator.');\n        }\n        throw new TypeError();\n    }\n}\nexports.default = wire;\n//# sourceMappingURL=wire.js.map","\"use strict\";\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for producing the ComponentDef object that is always\n * accessible via `vm.def`. This is lazily created during the creation of the first\n * instance of a component class, and shared across all instances.\n *\n * This structure can be used to synthetically create proxies, and understand the\n * shape of a component. It is also used internally to apply extra optimizations.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst fields_1 = require(\"../shared/fields\");\nconst attributes_1 = require(\"./attributes\");\nconst utils_1 = require(\"./utils\");\nconst component_1 = require(\"./component\");\nconst CtorToDefMap = new WeakMap();\nfunction getCtorProto(Ctor, subclassComponentName) {\n    let proto = language_1.getPrototypeOf(Ctor);\n    if (language_1.isNull(proto)) {\n        throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);\n    }\n    // covering the cases where the ref is circular in AMD\n    if (utils_1.isCircularModuleDependency(proto)) {\n        const p = utils_1.resolveCircularModuleDependency(proto);\n        if (process.env.NODE_ENV !== 'production') {\n            if (language_1.isNull(p)) {\n                throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);\n            }\n        }\n        // escape hatch for Locker and other abstractions to provide their own base class instead\n        // of our Base class without having to leak it to user-land. If the circular function returns\n        // itself, that's the signal that we have hit the end of the proto chain, which must always\n        // be base.\n        proto = p === proto ? base_lightning_element_1.BaseLightningElement : p;\n    }\n    return proto;\n}\nfunction createComponentDef(Ctor, meta, subclassComponentName) {\n    if (process.env.NODE_ENV !== 'production') {\n        // local to dev block\n        const ctorName = Ctor.name;\n        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n        assert_1.default.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n    }\n    const { name, template } = meta;\n    let decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);\n    // TODO: #1295 - refactor tests that are using this declaration manually\n    if (language_1.isUndefined(decoratorsMeta)) {\n        register_1.registerDecorators(Ctor, {\n            publicMethods: getOwnValue(Ctor, 'publicMethods'),\n            publicProps: getOwnValue(Ctor, 'publicProps'),\n            track: getOwnValue(Ctor, 'track'),\n            wire: getOwnValue(Ctor, 'wire'),\n        });\n        decoratorsMeta = register_1.getDecoratorsRegisteredMeta(Ctor);\n    }\n    let { props, methods, wire, track } = decoratorsMeta || utils_1.EmptyObject;\n    const proto = Ctor.prototype;\n    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render, } = proto;\n    const superProto = getCtorProto(Ctor, subclassComponentName);\n    const superDef = superProto !== base_lightning_element_1.BaseLightningElement\n        ? getComponentDef(superProto, subclassComponentName)\n        : null;\n    const SuperBridge = language_1.isNull(superDef) ? base_bridge_element_1.BaseBridgeElement : superDef.bridge;\n    const bridge = base_bridge_element_1.HTMLBridgeElementFactory(SuperBridge, language_1.getOwnPropertyNames(props), language_1.getOwnPropertyNames(methods));\n    if (!language_1.isNull(superDef)) {\n        props = language_1.assign(language_1.create(null), superDef.props, props);\n        methods = language_1.assign(language_1.create(null), superDef.methods, methods);\n        wire = superDef.wire || wire ? language_1.assign(language_1.create(null), superDef.wire, wire) : undefined;\n        track = language_1.assign(language_1.create(null), superDef.track, track);\n        connectedCallback = connectedCallback || superDef.connectedCallback;\n        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n        renderedCallback = renderedCallback || superDef.renderedCallback;\n        errorCallback = errorCallback || superDef.errorCallback;\n        render = render || superDef.render;\n    }\n    props = language_1.assign(language_1.create(null), HTML_PROPS, props);\n    const def = {\n        ctor: Ctor,\n        name,\n        wire,\n        track,\n        props,\n        methods,\n        bridge,\n        template,\n        connectedCallback,\n        disconnectedCallback,\n        renderedCallback,\n        errorCallback,\n        render,\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        language_1.freeze(Ctor.prototype);\n    }\n    return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC\n * constructors. This API is subject to change or being removed.\n */\nfunction isComponentConstructor(ctor) {\n    if (!language_1.isFunction(ctor)) {\n        return false;\n    }\n    // Fast path: LightningElement is part of the prototype chain of the constructor.\n    if (ctor.prototype instanceof base_lightning_element_1.BaseLightningElement) {\n        return true;\n    }\n    // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n    // climb up the constructor prototype chain to check in case there are circular dependencies\n    // to resolve.\n    let current = ctor;\n    do {\n        if (utils_1.isCircularModuleDependency(current)) {\n            const circularResolved = utils_1.resolveCircularModuleDependency(current);\n            // If the circular function returns itself, that's the signal that we have hit the end of the proto chain,\n            // which must always be a valid base constructor.\n            if (circularResolved === current) {\n                return true;\n            }\n            current = circularResolved;\n        }\n        if (current === base_lightning_element_1.BaseLightningElement) {\n            return true;\n        }\n    } while (!language_1.isNull(current) && (current = language_1.getPrototypeOf(current)));\n    // Finally return false if the LightningElement is not part of the prototype chain.\n    return false;\n}\nexports.isComponentConstructor = isComponentConstructor;\nfunction getOwnValue(o, key) {\n    const d = language_1.getOwnPropertyDescriptor(o, key);\n    return d && d.value;\n}\n/**\n * EXPERIMENTAL: This function allows for the collection of internal\n * component metadata. This API is subject to change or being removed.\n */\nfunction getComponentDef(Ctor, subclassComponentName) {\n    let def = CtorToDefMap.get(Ctor);\n    if (language_1.isUndefined(def)) {\n        if (!isComponentConstructor(Ctor)) {\n            throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n        }\n        let meta = component_1.getComponentRegisteredMeta(Ctor);\n        if (language_1.isUndefined(meta)) {\n            // TODO: #1295 - remove this workaround after refactoring tests\n            meta = {\n                template: undefined,\n                name: Ctor.name,\n            };\n        }\n        def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);\n        CtorToDefMap.set(Ctor, def);\n    }\n    return def;\n}\nexports.getComponentDef = getComponentDef;\n/**\n * EXPERIMENTAL: This function provides access to the component constructor,\n * given an HTMLElement. This API is subject to change or being removed.\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    if (elm instanceof HTMLElement) {\n        const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n        if (!language_1.isUndefined(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\nexports.getComponentConstructor = getComponentConstructor;\n// Only set prototype for public methods and properties\n// No DOM Patching occurs here\nfunction setElementProto(elm, def) {\n    language_1.setPrototypeOf(elm, def.bridge.prototype);\n}\nexports.setElementProto = setElementProto;\nconst html_properties_1 = require(\"./html-properties\");\nconst base_lightning_element_1 = require(\"./base-lightning-element\");\nconst base_bridge_element_1 = require(\"./base-bridge-element\");\nconst register_1 = require(\"./decorators/register\");\n// Typescript is inferring the wrong function type for this particular\n// overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n// @ts-ignore type-mismatch\nconst HTML_PROPS = language_1.ArrayReduce.call(language_1.getOwnPropertyNames(html_properties_1.HTMLElementOriginalDescriptors), (props, propName) => {\n    const attrName = attributes_1.getAttrNameFromPropName(propName);\n    props[propName] = {\n        config: 3,\n        type: 'any',\n        attr: attrName,\n    };\n    return props;\n}, language_1.create(null));\n//# sourceMappingURL=def.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst utils_1 = require(\"./utils\");\nconst vm_1 = require(\"./vm\");\nconst events_1 = __importDefault(require(\"./modules/events\"));\nconst attrs_1 = __importDefault(require(\"./modules/attrs\"));\nconst props_1 = __importDefault(require(\"./modules/props\"));\nconst computed_class_attr_1 = __importDefault(require(\"./modules/computed-class-attr\"));\nconst computed_style_attr_1 = __importDefault(require(\"./modules/computed-style-attr\"));\nconst static_class_attr_1 = __importDefault(require(\"./modules/static-class-attr\"));\nconst static_style_attr_1 = __importDefault(require(\"./modules/static-style-attr\"));\nconst context_1 = __importDefault(require(\"./modules/context\"));\nconst patch_1 = require(\"./patch\");\nconst snabbdom_1 = require(\"../3rdparty/snabbdom/snabbdom\");\nconst restrictions_1 = require(\"./restrictions\");\nconst patch_2 = require(\"./patch\");\nconst def_1 = require(\"./def\");\nconst noop = () => void 0;\nfunction observeElementChildNodes(elm) {\n    elm.$domManual$ = true;\n}\nfunction setElementShadowToken(elm, token) {\n    elm.$shadowToken$ = token;\n}\nfunction updateNodeHook(oldVnode, vnode) {\n    const { text } = vnode;\n    if (oldVnode.text !== text) {\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.unlockDomMutation();\n        }\n        /**\n         * Compiler will never produce a text property that is not string\n         */\n        vnode.elm.nodeValue = text;\n        if (process.env.NODE_ENV !== 'production') {\n            restrictions_1.lockDomMutation();\n        }\n    }\n}\nexports.updateNodeHook = updateNodeHook;\nfunction insertNodeHook(vnode, parentNode, referenceNode) {\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.unlockDomMutation();\n    }\n    parentNode.insertBefore(vnode.elm, referenceNode);\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.lockDomMutation();\n    }\n}\nexports.insertNodeHook = insertNodeHook;\nfunction removeNodeHook(vnode, parentNode) {\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.unlockDomMutation();\n    }\n    parentNode.removeChild(vnode.elm);\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.lockDomMutation();\n    }\n}\nexports.removeNodeHook = removeNodeHook;\nfunction createTextHook(vnode) {\n    const text = vnode.elm;\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        patch_2.patchTextNodeProto(text);\n    }\n}\nexports.createTextHook = createTextHook;\nfunction createCommentHook(vnode) {\n    const comment = vnode.elm;\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        patch_2.patchCommentNodeProto(comment);\n    }\n}\nexports.createCommentHook = createCommentHook;\nfunction createElmHook(vnode) {\n    events_1.default.create(vnode);\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    attrs_1.default.create(vnode);\n    props_1.default.create(vnode);\n    static_class_attr_1.default.create(vnode);\n    static_style_attr_1.default.create(vnode);\n    computed_class_attr_1.default.create(vnode);\n    computed_style_attr_1.default.create(vnode);\n    context_1.default.create(vnode);\n}\nexports.createElmHook = createElmHook;\nvar LWCDOMMode;\n(function (LWCDOMMode) {\n    LWCDOMMode[\"manual\"] = \"manual\";\n})(LWCDOMMode || (LWCDOMMode = {}));\nfunction fallbackElmHook(vnode) {\n    const { owner, sel } = vnode;\n    const elm = vnode.elm;\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        const { data: { context }, } = vnode;\n        const { shadowAttribute } = owner.context;\n        if (!language_1.isUndefined(context) &&\n            !language_1.isUndefined(context.lwc) &&\n            context.lwc.dom === LWCDOMMode.manual) {\n            // this element will now accept any manual content inserted into it\n            observeElementChildNodes(elm);\n        }\n        // when running in synthetic shadow mode, we need to set the shadowToken value\n        // into each element from the template, so they can be styled accordingly.\n        setElementShadowToken(elm, shadowAttribute);\n        patch_2.patchElementProto(elm, { sel });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        const { data: { context }, } = vnode;\n        const isPortal = !language_1.isUndefined(context) &&\n            !language_1.isUndefined(context.lwc) &&\n            context.lwc.dom === LWCDOMMode.manual;\n        restrictions_1.patchElementWithRestrictions(elm, { isPortal });\n    }\n}\nexports.fallbackElmHook = fallbackElmHook;\nfunction updateElmHook(oldVnode, vnode) {\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    attrs_1.default.update(oldVnode, vnode);\n    props_1.default.update(oldVnode, vnode);\n    computed_class_attr_1.default.update(oldVnode, vnode);\n    computed_style_attr_1.default.update(oldVnode, vnode);\n}\nexports.updateElmHook = updateElmHook;\nfunction insertCustomElmHook(vnode) {\n    const vm = vm_1.getCustomElementVM(vnode.elm);\n    vm_1.appendVM(vm);\n}\nexports.insertCustomElmHook = insertCustomElmHook;\nfunction updateChildrenHook(oldVnode, vnode) {\n    const { children, owner } = vnode;\n    const fn = patch_1.hasDynamicChildren(children) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;\n    vm_1.runWithBoundaryProtection(owner, owner.owner, noop, () => {\n        fn(vnode.elm, oldVnode.children, children);\n    }, noop);\n}\nexports.updateChildrenHook = updateChildrenHook;\nfunction allocateChildrenHook(vnode) {\n    const elm = vnode.elm;\n    const vm = vm_1.getCustomElementVM(elm);\n    const { children } = vnode;\n    vm.aChildren = children;\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        // slow path\n        vm_1.allocateInSlot(vm, children);\n        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n        vnode.children = utils_1.EmptyArray;\n    }\n}\nexports.allocateChildrenHook = allocateChildrenHook;\nfunction createViewModelHook(vnode) {\n    const elm = vnode.elm;\n    if (language_1.hasOwnProperty.call(elm, utils_1.ViewModelReflection)) {\n        // There is a possibility that a custom element is registered under tagName,\n        // in which case, the initialization is already carry on, and there is nothing else\n        // to do here since this hook is called right after invoking `document.createElement`.\n        return;\n    }\n    const { mode, ctor, owner } = vnode;\n    const def = def_1.getComponentDef(ctor);\n    def_1.setElementProto(elm, def);\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        const { shadowAttribute } = owner.context;\n        // when running in synthetic shadow mode, we need to set the shadowToken value\n        // into each element from the template, so they can be styled accordingly.\n        setElementShadowToken(elm, shadowAttribute);\n        patch_2.patchCustomElementProto(elm, { def });\n    }\n    vm_1.createVM(elm, ctor, {\n        mode,\n        owner,\n    });\n    const vm = vm_1.getCustomElementVM(elm);\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.patchCustomElementWithRestrictions(elm, utils_1.EmptyObject);\n    }\n}\nexports.createViewModelHook = createViewModelHook;\nfunction createCustomElmHook(vnode) {\n    events_1.default.create(vnode);\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    attrs_1.default.create(vnode);\n    props_1.default.create(vnode);\n    static_class_attr_1.default.create(vnode);\n    static_style_attr_1.default.create(vnode);\n    computed_class_attr_1.default.create(vnode);\n    computed_style_attr_1.default.create(vnode);\n    context_1.default.create(vnode);\n}\nexports.createCustomElmHook = createCustomElmHook;\nfunction createChildrenHook(vnode) {\n    const { elm, children } = vnode;\n    for (let j = 0; j < children.length; ++j) {\n        const ch = children[j];\n        if (ch != null) {\n            ch.hook.create(ch);\n            ch.hook.insert(ch, elm, null);\n        }\n    }\n}\nexports.createChildrenHook = createChildrenHook;\nfunction rerenderCustomElmHook(vnode) {\n    const vm = vm_1.getCustomElementVM(vnode.elm);\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    vm_1.rerenderVM(vm);\n}\nexports.rerenderCustomElmHook = rerenderCustomElmHook;\nfunction updateCustomElmHook(oldVnode, vnode) {\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    attrs_1.default.update(oldVnode, vnode);\n    props_1.default.update(oldVnode, vnode);\n    computed_class_attr_1.default.update(oldVnode, vnode);\n    computed_style_attr_1.default.update(oldVnode, vnode);\n}\nexports.updateCustomElmHook = updateCustomElmHook;\nfunction removeElmHook(vnode) {\n    // this method only needs to search on child vnodes from template\n    // to trigger the remove hook just in case some of those children\n    // are custom elements.\n    const { children, elm } = vnode;\n    for (let j = 0, len = children.length; j < len; ++j) {\n        const ch = children[j];\n        if (!language_1.isNull(ch)) {\n            ch.hook.remove(ch, elm);\n        }\n    }\n}\nexports.removeElmHook = removeElmHook;\nfunction removeCustomElmHook(vnode) {\n    // for custom elements we don't have to go recursively because the removeVM routine\n    // will take care of disconnecting any child VM attached to its shadow as well.\n    vm_1.removeVM(vm_1.getCustomElementVM(vnode.elm));\n}\nexports.removeCustomElmHook = removeCustomElmHook;\n//# sourceMappingURL=hooks.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../shared/language\");\nconst attributes_1 = require(\"./attributes\");\nconst main_1 = require(\"../polyfills/aria-properties/main\");\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\nexports.HTMLElementOriginalDescriptors = language_1.create(null);\nlanguage_1.forEach.call(main_1.ElementPrototypeAriaPropertyNames, (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n    const descriptor = language_1.getPropertyDescriptor(HTMLElement.prototype, propName);\n    if (!language_1.isUndefined(descriptor)) {\n        exports.HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\nlanguage_1.forEach.call(attributes_1.defaultDefHTMLPropertyNames, propName => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n    // this category, so, better to be sure.\n    const descriptor = language_1.getPropertyDescriptor(HTMLElement.prototype, propName);\n    if (!language_1.isUndefined(descriptor)) {\n        exports.HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\n//# sourceMappingURL=html-properties.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst context_1 = require(\"./context\");\nconst template_1 = require(\"./template\");\nconst language_1 = require(\"../shared/language\");\nconst vm_1 = require(\"./vm\");\nconst performance_timing_1 = require(\"./performance-timing\");\nexports.isRendering = false;\nexports.vmBeingRendered = null;\nexports.vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpProps' in vm, `${vm} is not a vm.`);\n    }\n    return exports.vmBeingConstructed === vm;\n}\nexports.isBeingConstructed = isBeingConstructed;\nfunction invokeComponentCallback(vm, fn, args) {\n    const { component, callHook, context, owner } = vm;\n    const ctx = context_1.currentContext;\n    let result;\n    vm_1.runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        context_1.establishContext(context);\n    }, () => {\n        // job\n        result = callHook(component, fn, args);\n    }, () => {\n        // post\n        context_1.establishContext(ctx);\n    });\n    return result;\n}\nexports.invokeComponentCallback = invokeComponentCallback;\nfunction invokeComponentConstructor(vm, Ctor) {\n    const vmBeingConstructedInception = exports.vmBeingConstructed;\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpProps' in vm, `${vm} is not a vm.`);\n    }\n    const { context } = vm;\n    const ctx = context_1.currentContext;\n    context_1.establishContext(context);\n    let error;\n    if (process.env.NODE_ENV !== 'production') {\n        performance_timing_1.startMeasure('constructor', vm);\n    }\n    exports.vmBeingConstructed = vm;\n    /**\n     * Constructors don't need to be wrapped with a boundary because for root elements\n     * it should throw, while elements from template are already wrapped by a boundary\n     * associated to the diffing algo.\n     */\n    try {\n        // job\n        const result = new Ctor();\n        // Check indirectly if the constructor result is an instance of LightningElement. Using\n        // the \"instanceof\" operator would not work here since Locker Service provides its own\n        // implementation of LightningElement, so we indirectly check if the base constructor is\n        // invoked by accessing the component on the vm.\n        if (exports.vmBeingConstructed.component !== result) {\n            throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n        }\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        context_1.establishContext(ctx);\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.endMeasure('constructor', vm);\n        }\n        exports.vmBeingConstructed = vmBeingConstructedInception;\n        if (!language_1.isUndefined(error)) {\n            error.wcStack = vm_1.getErrorComponentStack(vm.elm);\n            // re-throwing the original error annotated after restoring the context\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n}\nexports.invokeComponentConstructor = invokeComponentConstructor;\nfunction invokeComponentRenderMethod(vm) {\n    const { def: { render }, callHook, component, context, owner, } = vm;\n    const ctx = context_1.currentContext;\n    const isRenderingInception = exports.isRendering;\n    const vmBeingRenderedInception = exports.vmBeingRendered;\n    exports.isRendering = true;\n    exports.vmBeingRendered = vm;\n    let result;\n    vm_1.runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        context_1.establishContext(context);\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.startMeasure('render', vm);\n        }\n        exports.isRendering = true;\n        exports.vmBeingRendered = vm;\n    }, () => {\n        // job\n        const html = callHook(component, render);\n        result = template_1.evaluateTemplate(vm, html);\n    }, () => {\n        context_1.establishContext(ctx);\n        // post\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.endMeasure('render', vm);\n        }\n        exports.isRendering = isRenderingInception;\n        exports.vmBeingRendered = vmBeingRenderedInception;\n    });\n    return result || [];\n}\nexports.invokeComponentRenderMethod = invokeComponentRenderMethod;\nfunction invokeEventListener(vm, fn, thisValue, event) {\n    const { callHook, owner, context } = vm;\n    const ctx = context_1.currentContext;\n    vm_1.runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        context_1.establishContext(context);\n    }, () => {\n        // job\n        if (process.env.NODE_ENV !== 'production') {\n            assert_1.default.isTrue(language_1.isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n        }\n        callHook(thisValue, fn, [event]);\n    }, () => {\n        // post\n        context_1.establishContext(ctx);\n    });\n}\nexports.invokeEventListener = invokeEventListener;\n//# sourceMappingURL=invoker.js.map","\"use strict\";\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Polyfills\nrequire(\"../polyfills/proxy-concat/main\");\nrequire(\"../polyfills/aria-properties/main\");\n// TODO: #1296 - Revisit these exports and figure out a better separation\nvar upgrade_1 = require(\"./upgrade\");\nexports.createElement = upgrade_1.createElement;\nvar def_1 = require(\"./def\");\nexports.getComponentDef = def_1.getComponentDef;\nexports.isComponentConstructor = def_1.isComponentConstructor;\nexports.getComponentConstructor = def_1.getComponentConstructor;\nvar base_lightning_element_1 = require(\"./base-lightning-element\");\nexports.LightningElement = base_lightning_element_1.BaseLightningElement;\nvar services_1 = require(\"./services\");\nexports.register = services_1.register;\nvar membrane_1 = require(\"./membrane\");\nexports.unwrap = membrane_1.unwrap;\nvar secure_template_1 = require(\"./secure-template\");\nexports.registerTemplate = secure_template_1.registerTemplate;\nexports.sanitizeAttribute = secure_template_1.sanitizeAttribute;\nvar component_1 = require(\"./component\");\nexports.registerComponent = component_1.registerComponent;\nvar register_1 = require(\"./decorators/register\");\nexports.registerDecorators = register_1.registerDecorators;\nvar vm_1 = require(\"./vm\");\nexports.isNodeFromTemplate = vm_1.isNodeFromTemplate;\nvar api_1 = require(\"./decorators/api\");\nexports.api = api_1.default;\nvar track_1 = require(\"./decorators/track\");\nexports.track = track_1.default;\nvar readonly_1 = require(\"./decorators/readonly\");\nexports.readonly = readonly_1.default;\nvar wire_1 = require(\"./decorators/wire\");\nexports.wire = wire_1.default;\nvar decorate_1 = require(\"./decorators/decorate\");\nexports.decorate = decorate_1.default;\nvar wc_1 = require(\"./wc\");\nexports.buildCustomElementConstructor = wc_1.buildCustomElementConstructor;\n//# sourceMappingURL=main.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst observable_membrane_1 = __importDefault(require(\"observable-membrane\"));\nconst watcher_1 = require(\"./watcher\");\nfunction valueDistortion(value) {\n    return value;\n}\nexports.reactiveMembrane = new observable_membrane_1.default({\n    valueObserved: watcher_1.observeMutation,\n    valueMutated: watcher_1.notifyMutation,\n    valueDistortion,\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\nexports.unwrap = function (value) {\n    const unwrapped = exports.reactiveMembrane.unwrapProxy(value);\n    if (unwrapped !== value) {\n        // if value is a proxy, unwrap to access original value and apply distortion\n        return valueDistortion(unwrapped);\n    }\n    return value;\n};\n//# sourceMappingURL=membrane.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst attributes_1 = require(\"../attributes\");\nconst language_1 = require(\"../../shared/language\");\nconst utils_1 = require(\"../utils\");\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\nfunction updateAttrs(oldVnode, vnode) {\n    const { data: { attrs }, } = vnode;\n    if (language_1.isUndefined(attrs)) {\n        return;\n    }\n    let { data: { attrs: oldAttrs }, } = oldVnode;\n    if (oldAttrs === attrs) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(language_1.isUndefined(oldAttrs) || language_1.keys(oldAttrs).join(',') === language_1.keys(attrs).join(','), `vnode.data.attrs cannot change shape.`);\n    }\n    const elm = vnode.elm;\n    let key;\n    oldAttrs = language_1.isUndefined(oldAttrs) ? utils_1.EmptyObject : oldAttrs;\n    // update modified attributes, add new attributes\n    // this routine is only useful for data-* attributes in all kind of elements\n    // and aria-* in standard elements (custom elements will use props for these)\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            attributes_1.unlockAttribute(elm, key);\n            if (language_1.StringCharCodeAt.call(key, 3) === ColonCharCode) {\n                // Assume xml namespace\n                elm.setAttributeNS(xmlNS, key, cur);\n            }\n            else if (language_1.StringCharCodeAt.call(key, 5) === ColonCharCode) {\n                // Assume xlink namespace\n                elm.setAttributeNS(xlinkNS, key, cur);\n            }\n            else if (language_1.isNull(cur)) {\n                elm.removeAttribute(key);\n            }\n            else {\n                elm.setAttribute(key, cur);\n            }\n            attributes_1.lockAttribute(elm, key);\n        }\n    }\n}\nconst emptyVNode = { data: {} };\nexports.default = {\n    create: (vnode) => updateAttrs(emptyVNode, vnode),\n    update: updateAttrs,\n};\n//# sourceMappingURL=attrs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst utils_1 = require(\"../utils\");\nconst language_1 = require(\"../../shared/language\");\nconst classNameToClassMap = language_1.create(null);\nfunction getMapFromClassName(className) {\n    // Intentionally using == to match undefined and null values from computed style attribute\n    if (className == null) {\n        return utils_1.EmptyObject;\n    }\n    // computed class names must be string\n    className = language_1.isString(className) ? className : className + '';\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = language_1.create(null);\n    let start = 0;\n    let o;\n    const len = className.length;\n    for (o = 0; o < len; o++) {\n        if (language_1.StringCharCodeAt.call(className, o) === utils_1.SPACE_CHAR) {\n            if (o > start) {\n                map[language_1.StringSlice.call(className, start, o)] = true;\n            }\n            start = o + 1;\n        }\n    }\n    if (o > start) {\n        map[language_1.StringSlice.call(className, start, o)] = true;\n    }\n    classNameToClassMap[className] = map;\n    if (process.env.NODE_ENV !== 'production') {\n        // just to make sure that this object never changes as part of the diffing algo\n        language_1.freeze(map);\n    }\n    return map;\n}\nfunction updateClassAttribute(oldVnode, vnode) {\n    const { elm, data: { className: newClass }, } = vnode;\n    const { data: { className: oldClass }, } = oldVnode;\n    if (oldClass === newClass) {\n        return;\n    }\n    const { classList } = elm;\n    const newClassMap = getMapFromClassName(newClass);\n    const oldClassMap = getMapFromClassName(oldClass);\n    let name;\n    for (name in oldClassMap) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (language_1.isUndefined(newClassMap[name])) {\n            classList.remove(name);\n        }\n    }\n    for (name in newClassMap) {\n        if (language_1.isUndefined(oldClassMap[name])) {\n            classList.add(name);\n        }\n    }\n}\nconst emptyVNode = { data: {} };\nexports.default = {\n    create: (vnode) => updateClassAttribute(emptyVNode, vnode),\n    update: updateClassAttribute,\n};\n//# sourceMappingURL=computed-class-attr.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\nconst element_1 = require(\"../../env/element\");\n// The style property is a string when defined via an expression in the template.\nfunction updateStyleAttribute(oldVnode, vnode) {\n    const { style: newStyle } = vnode.data;\n    if (oldVnode.data.style === newStyle) {\n        return;\n    }\n    const elm = vnode.elm;\n    const { style } = elm;\n    if (!language_1.isString(newStyle) || newStyle === '') {\n        element_1.removeAttribute.call(elm, 'style');\n    }\n    else {\n        style.cssText = newStyle;\n    }\n}\nconst emptyVNode = { data: {} };\nexports.default = {\n    create: (vnode) => updateStyleAttribute(emptyVNode, vnode),\n    update: updateStyleAttribute,\n};\n//# sourceMappingURL=computed-style-attr.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\nconst utils_1 = require(\"../utils\");\nconst fields_1 = require(\"../../shared/fields\");\nfunction createContext(vnode) {\n    const { data: { context }, } = vnode;\n    if (language_1.isUndefined(context)) {\n        return;\n    }\n    const elm = vnode.elm;\n    const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n    if (!language_1.isUndefined(vm)) {\n        language_1.assign(vm.context, context);\n    }\n}\nconst contextModule = {\n    create: createContext,\n};\nexports.default = contextModule;\n//# sourceMappingURL=context.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\nfunction handleEvent(event, vnode) {\n    const { type } = event;\n    const { data: { on }, } = vnode;\n    const handler = on && on[type];\n    // call event handler if exists\n    if (handler) {\n        handler.call(undefined, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateAllEventListeners(oldVnode, vnode) {\n    if (language_1.isUndefined(oldVnode.listener)) {\n        createAllEventListeners(vnode);\n    }\n    else {\n        vnode.listener = oldVnode.listener;\n        vnode.listener.vnode = vnode;\n    }\n}\nfunction createAllEventListeners(vnode) {\n    const { data: { on }, } = vnode;\n    if (language_1.isUndefined(on)) {\n        return;\n    }\n    const elm = vnode.elm;\n    const listener = (vnode.listener = createListener());\n    listener.vnode = vnode;\n    let name;\n    for (name in on) {\n        elm.addEventListener(name, listener);\n    }\n}\nexports.default = {\n    update: updateAllEventListeners,\n    create: createAllEventListeners,\n};\n//# sourceMappingURL=events.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../../shared/assert\"));\nconst language_1 = require(\"../../shared/language\");\nconst fields_1 = require(\"../../shared/fields\");\nconst utils_1 = require(\"../utils\");\nconst base_bridge_element_1 = require(\"../base-bridge-element\");\nconst attributes_1 = require(\"../attributes\");\nfunction isLiveBindingProp(sel, key) {\n    // For special whitelisted properties, we check against the actual property value on the DOM element instead of\n    // relying on tracked property values.\n    return sel === 'input' && (key === 'value' || key === 'checked');\n}\nfunction update(oldVnode, vnode) {\n    const props = vnode.data.props;\n    if (language_1.isUndefined(props)) {\n        return;\n    }\n    const oldProps = oldVnode.data.props;\n    if (oldProps === props) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(language_1.isUndefined(oldProps) || language_1.keys(oldProps).join(',') === language_1.keys(props).join(','), 'vnode.data.props cannot change shape.');\n    }\n    const elm = vnode.elm;\n    const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n    const isFirstPatch = language_1.isUndefined(oldProps);\n    const isCustomElement = !language_1.isUndefined(vm);\n    const { sel } = vnode;\n    for (const key in props) {\n        const cur = props[key];\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(key in elm)) {\n                // TODO: #1297 - Move this validation to the compiler\n                assert_1.default.fail(`Unknown public property \"${key}\" of element <${sel}>. This is likely a typo on the corresponding attribute \"${attributes_1.getAttrNameFromPropName(key)}\".`);\n            }\n        }\n        // if it is the first time this element is patched, or the current value is different to the previous value...\n        if (isFirstPatch ||\n            cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {\n            if (isCustomElement) {\n                base_bridge_element_1.prepareForPropUpdate(vm); // this is just in case the vnode is actually a custom element\n            }\n            elm[key] = cur;\n        }\n    }\n}\nconst emptyVNode = { data: {} };\nexports.default = {\n    create: (vnode) => update(emptyVNode, vnode),\n    update,\n};\n//# sourceMappingURL=props.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\n// The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\nfunction createClassAttribute(vnode) {\n    const { elm, data: { classMap }, } = vnode;\n    if (language_1.isUndefined(classMap)) {\n        return;\n    }\n    const { classList } = elm;\n    for (const name in classMap) {\n        classList.add(name);\n    }\n}\nexports.default = {\n    create: createClassAttribute,\n};\n//# sourceMappingURL=static-class-attr.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../../shared/language\");\n// The HTML style property becomes the vnode.data.styleMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\nfunction createStyleAttribute(vnode) {\n    const { elm, data: { styleMap }, } = vnode;\n    if (language_1.isUndefined(styleMap)) {\n        return;\n    }\n    const { style } = elm;\n    for (const name in styleMap) {\n        style[name] = styleMap[name];\n    }\n}\nexports.default = {\n    create: createStyleAttribute,\n};\n//# sourceMappingURL=static-style-attr.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst element_1 = require(\"../env/element\");\nconst language_1 = require(\"../shared/language\");\nconst utils_1 = require(\"./utils\");\n// TODO: #1164 - eventually the engine should not do any of this work,\n// it should just interact with the DOM, and the polyfill should\n// take care of all these operation\nconst { PatchedElement, PatchedSlotElement, PatchedNode } = utils_1.useSyntheticShadow\n    ? Element.prototype.$lwcPolyfill$\n    : {};\n// Using a WeakMap instead of a WeakSet because this one works in IE11 :(\nconst FromIteration = new WeakMap();\n// dynamic children means it was generated by an iteration\n// in a template, and will require a more complex diffing algo.\nfunction markAsDynamicChildren(children) {\n    FromIteration.set(children, 1);\n}\nexports.markAsDynamicChildren = markAsDynamicChildren;\nfunction hasDynamicChildren(children) {\n    return FromIteration.has(children);\n}\nexports.hasDynamicChildren = hasDynamicChildren;\nlet TextNodeProto;\n// this method is supposed to be invoked when in fallback mode only\n// to patch text nodes generated by a template.\nfunction patchTextNodeProto(text) {\n    if (language_1.isUndefined(TextNodeProto)) {\n        TextNodeProto = PatchedNode(text).prototype;\n    }\n    language_1.setPrototypeOf(text, TextNodeProto);\n}\nexports.patchTextNodeProto = patchTextNodeProto;\nlet CommentNodeProto;\n// this method is supposed to be invoked when in fallback mode only\n// to patch comment nodes generated by a template.\nfunction patchCommentNodeProto(comment) {\n    if (language_1.isUndefined(CommentNodeProto)) {\n        CommentNodeProto = PatchedNode(comment).prototype;\n    }\n    language_1.setPrototypeOf(comment, CommentNodeProto);\n}\nexports.patchCommentNodeProto = patchCommentNodeProto;\nconst TagToProtoCache = language_1.create(null);\nfunction getPatchedElementClass(elm) {\n    switch (element_1.tagNameGetter.call(elm)) {\n        case 'SLOT':\n            return PatchedSlotElement(elm);\n    }\n    return PatchedElement(elm);\n}\n// this method is supposed to be invoked when in fallback mode only\n// to patch elements generated by a template.\nfunction patchElementProto(elm, options) {\n    const { sel } = options;\n    let proto = TagToProtoCache[sel];\n    if (language_1.isUndefined(proto)) {\n        proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;\n    }\n    language_1.setPrototypeOf(elm, proto);\n}\nexports.patchElementProto = patchElementProto;\nfunction patchCustomElementProto(elm, options) {\n    const { def } = options;\n    let patchedBridge = def.patchedBridge;\n    if (language_1.isUndefined(patchedBridge)) {\n        patchedBridge = def.patchedBridge = PatchedElement(elm);\n    }\n    // temporary patching the proto, eventually this should be just more nodes in the proto chain\n    language_1.setPrototypeOf(elm, patchedBridge.prototype);\n}\nexports.patchCustomElementProto = patchCustomElementProto;\n//# sourceMappingURL=patch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst element_1 = require(\"../env/element\");\nconst language_1 = require(\"../shared/language\");\nvar GlobalMeasurementPhase;\n(function (GlobalMeasurementPhase) {\n    GlobalMeasurementPhase[\"REHYDRATE\"] = \"lwc-rehydrate\";\n    GlobalMeasurementPhase[\"HYDRATE\"] = \"lwc-hydrate\";\n})(GlobalMeasurementPhase = exports.GlobalMeasurementPhase || (exports.GlobalMeasurementPhase = {}));\n// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\nconst isUserTimingSupported = typeof performance !== 'undefined' &&\n    typeof performance.mark === 'function' &&\n    typeof performance.clearMarks === 'function' &&\n    typeof performance.measure === 'function' &&\n    typeof performance.clearMeasures === 'function';\nfunction getMarkName(phase, vm) {\n    return `<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(vm.elm))} (${vm.idx})> - ${phase}`;\n}\nfunction start(markName) {\n    performance.mark(markName);\n}\nfunction end(measureName, markName) {\n    performance.measure(measureName, markName);\n    // Clear the created marks and measure to avoid filling the performance entries buffer.\n    // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n    performance.clearMarks(markName);\n    performance.clearMarks(measureName);\n}\nfunction noop() {\n    /* do nothing */\n}\nexports.startMeasure = !isUserTimingSupported\n    ? noop\n    : function (phase, vm) {\n        const markName = getMarkName(phase, vm);\n        start(markName);\n    };\nexports.endMeasure = !isUserTimingSupported\n    ? noop\n    : function (phase, vm) {\n        const markName = getMarkName(phase, vm);\n        end(markName, markName);\n    };\n// Global measurements can be nested into each others (e.g. nested component creation via createElement). In those cases\n// the VM is used to create unique mark names at each level.\nexports.startGlobalMeasure = !isUserTimingSupported\n    ? noop\n    : function (phase, vm) {\n        const markName = language_1.isUndefined(vm) ? phase : getMarkName(phase, vm);\n        start(markName);\n    };\nexports.endGlobalMeasure = !isUserTimingSupported\n    ? noop\n    : function (phase, vm) {\n        const markName = language_1.isUndefined(vm) ? phase : getMarkName(phase, vm);\n        end(phase, markName);\n    };\n//# sourceMappingURL=performance-timing.js.map","\"use strict\";\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint no-production-assert: \"off\" */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst attributes_1 = require(\"./attributes\");\nconst invoker_1 = require(\"./invoker\");\nconst vm_1 = require(\"./vm\");\nconst element_1 = require(\"../env/element\");\nfunction generateDataDescriptor(options) {\n    return language_1.assign({\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    }, options);\n}\nfunction generateAccessorDescriptor(options) {\n    return language_1.assign({\n        configurable: true,\n        enumerable: true,\n    }, options);\n}\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    isDomMutationAllowed = true;\n}\nexports.unlockDomMutation = unlockDomMutation;\nfunction lockDomMutation() {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    isDomMutationAllowed = false;\n}\nexports.lockDomMutation = lockDomMutation;\nfunction portalRestrictionErrorMessage(name, type) {\n    return `The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`;\n}\nfunction getNodeRestrictionsDescriptors(node, options) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    // getPropertyDescriptor here recursively looks up the prototype chain\n    // and returns the first descriptor for the property\n    const originalTextContentDescriptor = language_1.getPropertyDescriptor(node, 'textContent');\n    const originalNodeValueDescriptor = language_1.getPropertyDescriptor(node, 'nodeValue');\n    const { appendChild, insertBefore, removeChild, replaceChild } = node;\n    return {\n        appendChild: generateDataDescriptor({\n            value(aChild) {\n                if (this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('appendChild', 'method'), this);\n                }\n                return appendChild.call(this, aChild);\n            },\n        }),\n        insertBefore: generateDataDescriptor({\n            value(newNode, referenceNode) {\n                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('insertBefore', 'method'), this);\n                }\n                return insertBefore.call(this, newNode, referenceNode);\n            },\n        }),\n        removeChild: generateDataDescriptor({\n            value(aChild) {\n                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('removeChild', 'method'), this);\n                }\n                return removeChild.call(this, aChild);\n            },\n        }),\n        replaceChild: generateDataDescriptor({\n            value(newChild, oldChild) {\n                if (this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('replaceChild', 'method'), this);\n                }\n                return replaceChild.call(this, newChild, oldChild);\n            },\n        }),\n        nodeValue: generateAccessorDescriptor({\n            get() {\n                return originalNodeValueDescriptor.get.call(this);\n            },\n            set(value) {\n                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('nodeValue', 'property'), this);\n                }\n                originalNodeValueDescriptor.set.call(this, value);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(value) {\n                if (this instanceof Element && language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('textContent', 'property'), this);\n                }\n                originalTextContentDescriptor.set.call(this, value);\n            },\n        }),\n    };\n}\nfunction getElementRestrictionsDescriptors(elm, options) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const descriptors = getNodeRestrictionsDescriptors(elm, options);\n    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');\n    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');\n    language_1.assign(descriptors, {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                if (language_1.isFalse(options.isPortal)) {\n                    assert_1.default.logError(portalRestrictionErrorMessage('innerHTML', 'property'), this);\n                }\n                return originalInnerHTMLDescriptor.set.call(this, value);\n            },\n        }),\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n            },\n        }),\n    });\n    return descriptors;\n}\nfunction getShadowRootRestrictionsDescriptors(sr, options) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    // blacklisting properties in dev mode only to avoid people doing the wrong\n    // thing when using the real shadow root, because if that's the case,\n    // the component will not work when running with synthetic shadow.\n    const originalQuerySelector = sr.querySelector;\n    const originalQuerySelectorAll = sr.querySelectorAll;\n    const originalAddEventListener = sr.addEventListener;\n    const descriptors = getNodeRestrictionsDescriptors(sr, options);\n    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(sr, 'innerHTML');\n    const originalTextContentDescriptor = language_1.getPropertyDescriptor(sr, 'textContent');\n    language_1.assign(descriptors, {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type) {\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(sr)} by adding an event listener for \"${type}\".`);\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n        querySelector: generateDataDescriptor({\n            value() {\n                const vm = vm_1.getShadowRootVM(this);\n                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalQuerySelector.apply(this, arguments);\n            },\n        }),\n        querySelectorAll: generateDataDescriptor({\n            value() {\n                const vm = vm_1.getShadowRootVM(this);\n                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalQuerySelectorAll.apply(this, arguments);\n            },\n        }),\n    });\n    const BlackListedShadowRootMethods = {\n        cloneNode: 0,\n        getElementById: 0,\n        getSelection: 0,\n        elementsFromPoint: 0,\n        dispatchEvent: 0,\n    };\n    language_1.forEach.call(language_1.getOwnPropertyNames(BlackListedShadowRootMethods), (methodName) => {\n        const descriptor = generateAccessorDescriptor({\n            get() {\n                throw new Error(`Disallowed method \"${methodName}\" in ShadowRoot.`);\n            },\n        });\n        descriptors[methodName] = descriptor;\n    });\n    return descriptors;\n}\n// Custom Elements Restrictions:\n// -----------------------------\nfunction getAttributePatched(attrName) {\n    if (process.env.NODE_ENV !== 'production') {\n        const vm = vm_1.getCustomElementVM(this);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    return element_1.getAttribute.apply(this, language_1.ArraySlice.call(arguments));\n}\nfunction setAttributePatched(attrName, _newValue) {\n    const vm = vm_1.getCustomElementVM(this);\n    if (process.env.NODE_ENV !== 'production') {\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    element_1.setAttribute.apply(this, language_1.ArraySlice.call(arguments));\n}\nfunction setAttributeNSPatched(attrNameSpace, attrName, _newValue) {\n    const vm = vm_1.getCustomElementVM(this);\n    if (process.env.NODE_ENV !== 'production') {\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    element_1.setAttributeNS.apply(this, language_1.ArraySlice.call(arguments));\n}\nfunction removeAttributePatched(attrName) {\n    const vm = vm_1.getCustomElementVM(this);\n    // marking the set is needed for the AOM polyfill\n    if (process.env.NODE_ENV !== 'production') {\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    element_1.removeAttribute.apply(this, language_1.ArraySlice.call(arguments));\n}\nfunction removeAttributeNSPatched(attrNameSpace, attrName) {\n    const vm = vm_1.getCustomElementVM(this);\n    if (process.env.NODE_ENV !== 'production') {\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    element_1.removeAttributeNS.apply(this, language_1.ArraySlice.call(arguments));\n}\nfunction assertAttributeReflectionCapability(vm, attrName) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const propName = language_1.isString(attrName)\n        ? attributes_1.getPropNameFromAttrName(language_1.StringToLowerCase.call(attrName))\n        : null;\n    const { elm, def: { props: propsConfig }, } = vm;\n    if (isNodeFromVNode(elm) &&\n        attributes_1.isAttributeLocked(elm, attrName) &&\n        propsConfig &&\n        propName &&\n        propsConfig[propName]) {\n        assert_1.default.logError(`Invalid attribute access for \\`${attrName}\\`. Use the corresponding property \\`${propName}\\` instead.`, elm);\n    }\n}\nfunction getCustomElementRestrictionsDescriptors(elm, options) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const descriptors = getNodeRestrictionsDescriptors(elm, options);\n    const originalAddEventListener = elm.addEventListener;\n    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');\n    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');\n    const originalTextContentDescriptor = language_1.getPropertyDescriptor(elm, 'textContent');\n    return language_1.assign(descriptors, {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n            },\n        }),\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type) {\n                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(elm)} by adding an event listener for \"${type}\".`);\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n        // replacing mutators and accessors on the element itself to catch any mutation\n        getAttribute: generateDataDescriptor({\n            value: getAttributePatched,\n        }),\n        setAttribute: generateDataDescriptor({\n            value: setAttributePatched,\n        }),\n        setAttributeNS: generateDataDescriptor({\n            value: setAttributeNSPatched,\n        }),\n        removeAttribute: generateDataDescriptor({\n            value: removeAttributePatched,\n        }),\n        removeAttributeNS: generateDataDescriptor({\n            value: removeAttributeNSPatched,\n        }),\n    });\n}\nfunction getComponentRestrictionsDescriptors(cmp) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const originalSetAttribute = cmp.setAttribute;\n    return {\n        setAttribute: generateDataDescriptor({\n            value(attrName, _value) {\n                if (language_1.isString(attrName)) {\n                    const propName = attributes_1.getPropNameFromAttrName(attrName);\n                    const globalAttrName = attributes_1.globalHTMLProperties[propName] && attributes_1.globalHTMLProperties[propName].attribute;\n                    // Check that the attribute name of the global property is the same as the\n                    // attribute name being set by setAttribute.\n                    if (attrName === globalAttrName) {\n                        const { error } = attributes_1.globalHTMLProperties[propName];\n                        if (error) {\n                            assert_1.default.logError(error, vm_1.getComponentVM(this).elm);\n                        }\n                    }\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                originalSetAttribute.apply(this, arguments);\n            },\n            configurable: true,\n            enumerable: false,\n        }),\n        tagName: generateAccessorDescriptor({\n            get() {\n                throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.`);\n            },\n            configurable: true,\n            enumerable: false,\n        }),\n    };\n}\nfunction getLightingElementProtypeRestrictionsDescriptors(proto) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const descriptors = {};\n    language_1.forEach.call(language_1.getOwnPropertyNames(attributes_1.globalHTMLProperties), (propName) => {\n        if (propName in proto) {\n            return; // no need to redefine something that we are already exposing\n        }\n        descriptors[propName] = generateAccessorDescriptor({\n            get() {\n                const { error, attribute } = attributes_1.globalHTMLProperties[propName];\n                const msg = [];\n                msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n                if (error) {\n                    msg.push(error);\n                }\n                else if (attribute) {\n                    msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n                }\n                assert_1.default.logError(msg.join('\\n'), vm_1.getComponentVM(this).elm);\n            },\n            set() {\n                const { readOnly } = attributes_1.globalHTMLProperties[propName];\n                if (readOnly) {\n                    assert_1.default.logError(`The global HTML property \\`${propName}\\` is read-only.`);\n                }\n            },\n        });\n    });\n    return descriptors;\n}\nfunction isNodeFromVNode(node) {\n    return !!node.$fromTemplate$;\n}\nfunction markNodeFromVNode(node) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    node.$fromTemplate$ = true;\n}\nexports.markNodeFromVNode = markNodeFromVNode;\nfunction patchElementWithRestrictions(elm, options) {\n    language_1.defineProperties(elm, getElementRestrictionsDescriptors(elm, options));\n}\nexports.patchElementWithRestrictions = patchElementWithRestrictions;\n// This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\nfunction patchShadowRootWithRestrictions(sr, options) {\n    language_1.defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));\n}\nexports.patchShadowRootWithRestrictions = patchShadowRootWithRestrictions;\nfunction patchCustomElementWithRestrictions(elm, options) {\n    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);\n    const elmProto = language_1.getPrototypeOf(elm);\n    language_1.setPrototypeOf(elm, language_1.create(elmProto, restrictionsDescriptors));\n}\nexports.patchCustomElementWithRestrictions = patchCustomElementWithRestrictions;\nfunction patchComponentWithRestrictions(cmp) {\n    language_1.defineProperties(cmp, getComponentRestrictionsDescriptors(cmp));\n}\nexports.patchComponentWithRestrictions = patchComponentWithRestrictions;\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n    language_1.defineProperties(proto, getLightingElementProtypeRestrictionsDescriptors(proto));\n}\nexports.patchLightningElementPrototypeWithRestrictions = patchLightningElementPrototypeWithRestrictions;\n//# sourceMappingURL=restrictions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n    return [];\n}\nexports.defaultEmptyTemplate = defaultEmptyTemplate;\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n    return signedTemplateSet.has(tpl);\n}\nexports.isTemplateRegistered = isTemplateRegistered;\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerTemplate(tpl) {\n    signedTemplateSet.add(tpl);\n    // chaining this method as a way to wrap existing\n    // assignment of templates easily, without too much transformation\n    return tpl;\n}\nexports.registerTemplate = registerTemplate;\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker\n * Service and other similar libraries to sanitize vulnerable attributes.\n * This API is subject to change or being removed.\n */\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n    // locker-service patches this function during runtime to sanitize vulnerable attributes.\n    // when ran off-core this function becomes a noop and returns the user authored value.\n    return attrValue;\n}\nexports.sanitizeAttribute = sanitizeAttribute;\n//# sourceMappingURL=secure-template.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nexports.Services = language_1.create(null);\nconst hooks = [\n    'wiring',\n    'locator',\n    'rendered',\n    'connected',\n    'disconnected',\n];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\nfunction register(service) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isObject(service), `Invalid service declaration, ${service}: service must be an object`);\n    }\n    for (let i = 0; i < hooks.length; ++i) {\n        const hookName = hooks[i];\n        if (hookName in service) {\n            let l = exports.Services[hookName];\n            if (language_1.isUndefined(l)) {\n                exports.Services[hookName] = l = [];\n            }\n            language_1.ArrayPush.call(l, service[hookName]);\n        }\n    }\n}\nexports.register = register;\nfunction invokeServiceHook(vm, cbs) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(language_1.isArray(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n    }\n    const { component, data, def, context } = vm;\n    for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].call(undefined, component, data, def, context);\n    }\n}\nexports.invokeServiceHook = invokeServiceHook;\n//# sourceMappingURL=services.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst api = __importStar(require(\"./api\"));\nconst utils_1 = require(\"./utils\");\nconst element_1 = require(\"../env/element\");\nconst CachedStyleFragments = language_1.create(null);\nfunction createStyleElement(styleContent) {\n    const elm = document.createElement('style');\n    elm.type = 'text/css';\n    elm.textContent = styleContent;\n    return elm;\n}\nfunction getCachedStyleElement(styleContent) {\n    let fragment = CachedStyleFragments[styleContent];\n    if (language_1.isUndefined(fragment)) {\n        fragment = document.createDocumentFragment();\n        const styleElm = createStyleElement(styleContent);\n        fragment.appendChild(styleElm);\n        CachedStyleFragments[styleContent] = fragment;\n    }\n    return fragment.cloneNode(true).firstChild;\n}\nconst globalStyleParent = document.head || document.body || document;\nconst InsertedGlobalStyleContent = language_1.create(null);\nfunction insertGlobalStyle(styleContent) {\n    // inserts the global style when needed, otherwise does nothing\n    if (language_1.isUndefined(InsertedGlobalStyleContent[styleContent])) {\n        InsertedGlobalStyleContent[styleContent] = true;\n        const elm = createStyleElement(styleContent);\n        globalStyleParent.appendChild(elm);\n    }\n}\nfunction createStyleVNode(elm) {\n    const vnode = api.h('style', {\n        key: 'style',\n    }, utils_1.EmptyArray);\n    // Force the diffing algo to use the cloned style.\n    vnode.elm = elm;\n    return vnode;\n}\n/**\n * Reset the styling token applied to the host element.\n */\nfunction resetStyleAttributes(vm) {\n    const { context, elm } = vm;\n    // Remove the style attribute currently applied to the host element.\n    const oldHostAttribute = context.hostAttribute;\n    if (!language_1.isUndefined(oldHostAttribute)) {\n        element_1.removeAttribute.call(elm, oldHostAttribute);\n    }\n    // Reset the scoping attributes associated to the context.\n    context.hostAttribute = context.shadowAttribute = undefined;\n}\nexports.resetStyleAttributes = resetStyleAttributes;\n/**\n * Apply/Update the styling token applied to the host element.\n */\nfunction applyStyleAttributes(vm, hostAttribute, shadowAttribute) {\n    const { context, elm } = vm;\n    // Remove the style attribute currently applied to the host element.\n    element_1.setAttribute.call(elm, hostAttribute, '');\n    context.hostAttribute = hostAttribute;\n    context.shadowAttribute = shadowAttribute;\n}\nexports.applyStyleAttributes = applyStyleAttributes;\nfunction collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {\n    language_1.forEach.call(stylesheets, sheet => {\n        if (language_1.isArray(sheet)) {\n            collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);\n        }\n        else {\n            aggregatorFn(sheet(hostSelector, shadowSelector, isNative));\n        }\n    });\n}\nfunction evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(language_1.isArray(stylesheets), `Invalid stylesheets.`);\n    }\n    if (utils_1.useSyntheticShadow) {\n        const hostSelector = `[${hostAttribute}]`;\n        const shadowSelector = `[${shadowAttribute}]`;\n        collectStylesheets(stylesheets, hostSelector, shadowSelector, false, textContent => {\n            insertGlobalStyle(textContent);\n        });\n        return null;\n    }\n    else {\n        // Native shadow in place, we need to act accordingly by using the `:host` selector, and an\n        // empty shadow selector since it is not really needed.\n        let buffer = '';\n        collectStylesheets(stylesheets, language_1.emptyString, language_1.emptyString, true, textContent => {\n            buffer += textContent;\n        });\n        return createStyleVNode(getCachedStyleElement(buffer));\n    }\n}\nexports.evaluateCSS = evaluateCSS;\n//# sourceMappingURL=stylesheet.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst api = __importStar(require(\"./api\"));\nconst vm_1 = require(\"./vm\");\nconst utils_1 = require(\"./utils\");\nconst secure_template_1 = require(\"./secure-template\");\nexports.registerTemplate = secure_template_1.registerTemplate;\nconst stylesheet_1 = require(\"./stylesheet\");\nconst EmptySlots = language_1.create(null);\nfunction validateSlots(vm, html) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const { cmpSlots = EmptySlots } = vm;\n    const { slots = utils_1.EmptyArray } = html;\n    for (const slotName in cmpSlots) {\n        // eslint-disable-next-line no-production-assert\n        assert_1.default.isTrue(language_1.isArray(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${language_1.toString(cmpSlots[slotName])} for slot \"${slotName}\" in ${vm}.`);\n        if (slotName !== '' && language_1.ArrayIndexOf.call(slots, slotName) === -1) {\n            // TODO: #1297 - this should never really happen because the compiler should always validate\n            // eslint-disable-next-line no-production-assert\n            assert_1.default.logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm.elm);\n        }\n    }\n}\nfunction validateFields(vm, html) {\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const { component } = vm;\n    // validating identifiers used by template that should be provided by the component\n    const { ids = [] } = html;\n    language_1.forEach.call(ids, (propName) => {\n        if (!(propName in component)) {\n            // eslint-disable-next-line no-production-assert\n            assert_1.default.logError(`The template rendered by ${vm} references \\`this.${propName}\\`, which is not declared. Check for a typo in the template.`, vm.elm);\n        }\n    });\n}\nfunction evaluateTemplate(vm, html) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(language_1.isFunction(html), `evaluateTemplate() second argument must be an imported template instead of ${language_1.toString(html)}`);\n    }\n    const { component, context, cmpSlots, cmpTemplate } = vm;\n    // reset the cache memoizer for template when needed\n    if (html !== cmpTemplate) {\n        // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)\n        if (!language_1.isUndefined(cmpTemplate)) {\n            // It is important to reset the content to avoid reusing similar elements generated from a different\n            // template, because they could have similar IDs, and snabbdom just rely on the IDs.\n            vm_1.resetShadowRoot(vm);\n        }\n        // Check that the template was built by the compiler\n        if (!secure_template_1.isTemplateRegistered(html)) {\n            throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${language_1.toString(html)}.`);\n        }\n        vm.cmpTemplate = html;\n        // Populate context with template information\n        context.tplCache = language_1.create(null);\n        stylesheet_1.resetStyleAttributes(vm);\n        const { stylesheets, stylesheetTokens } = html;\n        if (language_1.isUndefined(stylesheets) || stylesheets.length === 0) {\n            context.styleVNode = null;\n        }\n        else if (!language_1.isUndefined(stylesheetTokens)) {\n            const { hostAttribute, shadowAttribute } = stylesheetTokens;\n            stylesheet_1.applyStyleAttributes(vm, hostAttribute, shadowAttribute);\n            // Caching style vnode so it can be reused on every render\n            context.styleVNode = stylesheet_1.evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // one time operation for any new template returned by render()\n            // so we can warn if the template is attempting to use a binding\n            // that is not provided by the component instance.\n            validateFields(vm, html);\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isObject(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`);\n        // validating slots in every rendering since the allocated content might change over time\n        validateSlots(vm, html);\n    }\n    const vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);\n    const { styleVNode } = context;\n    if (!language_1.isNull(styleVNode)) {\n        language_1.ArrayUnshift.call(vnodes, styleVNode);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(language_1.isArray(vnodes), `Compiler should produce html functions that always return an array.`);\n    }\n    return vnodes;\n}\nexports.evaluateTemplate = evaluateTemplate;\n//# sourceMappingURL=template.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst vm_1 = require(\"./vm\");\nconst utils_1 = require(\"./utils\");\nconst fields_1 = require(\"../shared/fields\");\nconst patch_1 = require(\"./patch\");\nconst def_1 = require(\"./def\");\nconst restrictions_1 = require(\"./restrictions\");\nconst performance_timing_1 = require(\"./performance-timing\");\nconst node_1 = require(\"../env/node\");\nconst ConnectingSlot = fields_1.createFieldName('connecting');\nconst DisconnectingSlot = fields_1.createFieldName('disconnecting');\nfunction callNodeSlot(node, slot) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = fields_1.getInternalField(node, slot);\n    if (!language_1.isUndefined(fn)) {\n        fn();\n    }\n    return node; // for convenience\n}\n// monkey patching Node methods to be able to detect the insertions and removal of\n// root elements created via createElement.\nlanguage_1.assign(Node.prototype, {\n    appendChild(newChild) {\n        const appendedNode = node_1.appendChild.call(this, newChild);\n        return callNodeSlot(appendedNode, ConnectingSlot);\n    },\n    insertBefore(newChild, referenceNode) {\n        const insertedNode = node_1.insertBefore.call(this, newChild, referenceNode);\n        return callNodeSlot(insertedNode, ConnectingSlot);\n    },\n    removeChild(oldChild) {\n        const removedNode = node_1.removeChild.call(this, oldChild);\n        return callNodeSlot(removedNode, DisconnectingSlot);\n    },\n    replaceChild(newChild, oldChild) {\n        const replacedNode = node_1.replaceChild.call(this, newChild, oldChild);\n        callNodeSlot(replacedNode, DisconnectingSlot);\n        callNodeSlot(newChild, ConnectingSlot);\n        return replacedNode;\n    },\n});\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement\n * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)\n * with the slightly difference that in the options, you can pass the `is`\n * property set to a Constructor instead of just a string value. The intent\n * is to allow the creation of an element controlled by LWC without having\n * to register the element as a custom element. E.g.:\n *\n * const el = createElement('x-foo', { is: FooCtor });\n *\n * If the value of `is` attribute is not a constructor,\n * then it throws a TypeError.\n */\nfunction createElement(sel, options) {\n    if (!language_1.isObject(options) || language_1.isNull(options)) {\n        throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${language_1.toString(options)}\".`);\n    }\n    let Ctor = options.is;\n    if (!language_1.isFunction(Ctor)) {\n        throw new TypeError(`\"createElement\" function expects a \"is\" option with a valid component constructor.`);\n    }\n    const mode = options.mode !== 'closed' ? 'open' : 'closed';\n    // Create element with correct tagName\n    const element = document.createElement(sel);\n    if (!language_1.isUndefined(fields_1.getInternalField(element, utils_1.ViewModelReflection))) {\n        // There is a possibility that a custom element is registered under tagName,\n        // in which case, the initialization is already carry on, and there is nothing else\n        // to do here.\n        return element;\n    }\n    if (utils_1.isCircularModuleDependency(Ctor)) {\n        Ctor = utils_1.resolveCircularModuleDependency(Ctor);\n    }\n    const def = def_1.getComponentDef(Ctor);\n    def_1.setElementProto(element, def);\n    if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n        patch_1.patchCustomElementProto(element, {\n            def,\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        restrictions_1.patchCustomElementWithRestrictions(element, utils_1.EmptyObject);\n    }\n    // In case the element is not initialized already, we need to carry on the manual creation\n    vm_1.createVM(element, Ctor, { mode, isRoot: true, owner: null });\n    // Handle insertion and removal from the DOM manually\n    fields_1.setInternalField(element, ConnectingSlot, () => {\n        const vm = vm_1.getCustomElementVM(element);\n        performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE, vm);\n        if (vm.state === vm_1.VMState.connected) {\n            // usually means moving the element from one place to another, which is observable via life-cycle hooks\n            vm_1.removeRootVM(vm);\n        }\n        vm_1.appendRootVM(vm);\n        performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.HYDRATE, vm);\n    });\n    fields_1.setInternalField(element, DisconnectingSlot, () => {\n        const vm = vm_1.getCustomElementVM(element);\n        vm_1.removeRootVM(vm);\n    });\n    return element;\n}\nexports.createElement = createElement;\n//# sourceMappingURL=upgrade.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"../shared/language\");\nconst fields_1 = require(\"../shared/fields\");\nlet nextTickCallbackQueue = [];\nexports.SPACE_CHAR = 32;\nexports.EmptyObject = language_1.seal(language_1.create(null));\nexports.EmptyArray = language_1.seal([]);\nexports.ViewModelReflection = fields_1.createFieldName('ViewModel');\nfunction flushCallbackQueue() {\n    if (process.env.NODE_ENV !== 'production') {\n        if (nextTickCallbackQueue.length === 0) {\n            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n        }\n    }\n    const callbacks = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\nfunction addCallbackToNextTick(callback) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!language_1.isFunction(callback)) {\n            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n        }\n    }\n    if (nextTickCallbackQueue.length === 0) {\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    language_1.ArrayPush.call(nextTickCallbackQueue, callback);\n}\nexports.addCallbackToNextTick = addCallbackToNextTick;\nfunction isCircularModuleDependency(value) {\n    return language_1.hasOwnProperty.call(value, '__circular__');\n}\nexports.isCircularModuleDependency = isCircularModuleDependency;\n/**\n * When LWC is used in the context of an Aura application, the compiler produces AMD\n * modules, that doesn't resolve properly circular dependencies between modules. In order\n * to circumvent this issue, the module loader returns a factory with a symbol attached\n * to it.\n *\n * This method returns the resolved value if it received a factory as argument. Otherwise\n * it returns the original value.\n */\nfunction resolveCircularModuleDependency(fn) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!language_1.isFunction(fn)) {\n            throw new TypeError(`Circular module dependency must be a function.`);\n        }\n    }\n    return fn();\n}\nexports.resolveCircularModuleDependency = resolveCircularModuleDependency;\nexports.useSyntheticShadow = language_1.hasOwnProperty.call(Element.prototype, '$shadowToken$');\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst def_1 = require(\"./def\");\nconst component_1 = require(\"./component\");\nconst patch_1 = require(\"./patch\");\nconst language_1 = require(\"../shared/language\");\nconst fields_1 = require(\"../shared/fields\");\nconst utils_1 = require(\"./utils\");\nconst services_1 = require(\"./services\");\nconst invoker_1 = require(\"./invoker\");\nconst dom_1 = require(\"../env/dom\");\nconst performance_timing_1 = require(\"./performance-timing\");\nconst element_1 = require(\"../env/element\");\nconst node_1 = require(\"../env/node\");\nconst snabbdom_1 = require(\"../3rdparty/snabbdom/snabbdom\");\n// Object of type ShadowRoot for instance checks\nconst GlobalShadowRoot = window.ShadowRoot;\nvar VMState;\n(function (VMState) {\n    VMState[VMState[\"created\"] = 0] = \"created\";\n    VMState[VMState[\"connected\"] = 1] = \"connected\";\n    VMState[VMState[\"disconnected\"] = 2] = \"disconnected\";\n})(VMState = exports.VMState || (exports.VMState = {}));\nlet idx = 0;\nfunction callHook(cmp, fn, args = []) {\n    return fn.apply(cmp, args);\n}\nfunction setHook(cmp, prop, newValue) {\n    cmp[prop] = newValue;\n}\nfunction getHook(cmp, prop) {\n    return cmp[prop];\n}\nfunction rerenderVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    rehydrate(vm);\n}\nexports.rerenderVM = rerenderVM;\nfunction appendRootVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    runConnectedCallback(vm);\n    rehydrate(vm);\n}\nexports.appendRootVM = appendRootVM;\nfunction appendVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(vm.state === VMState.created, `${vm} cannot be recycled.`);\n    }\n    runConnectedCallback(vm);\n    rehydrate(vm);\n}\nexports.appendVM = appendVM;\n// just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\nfunction resetComponentStateWhenRemoved(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { state } = vm;\n    if (state !== VMState.disconnected) {\n        runDisconnectedCallback(vm);\n        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n        runShadowChildNodesDisconnectedCallback(vm);\n        runLightChildNodesDisconnectedCallback(vm);\n    }\n}\n// this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\nfunction removeVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(vm.state === VMState.connected, `${vm} must be inserted.`);\n    }\n    resetComponentStateWhenRemoved(vm);\n}\nexports.removeVM = removeVM;\n// this method is triggered by the removal of a root element from the DOM.\nfunction removeRootVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    resetComponentStateWhenRemoved(vm);\n}\nexports.removeRootVM = removeRootVM;\nfunction createVM(elm, Ctor, options) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(elm instanceof HTMLElement, `VM creation requires a DOM element instead of ${elm}.`);\n    }\n    const def = def_1.getComponentDef(Ctor);\n    const { isRoot, mode, owner } = options;\n    idx += 1;\n    const uninitializedVm = {\n        // component creation index is defined once, and never reset, it can\n        // be preserved from one insertion to another without any issue\n        idx,\n        state: VMState.created,\n        isScheduled: false,\n        isDirty: true,\n        isRoot: language_1.isTrue(isRoot),\n        mode,\n        def,\n        owner,\n        elm,\n        data: utils_1.EmptyObject,\n        context: language_1.create(null),\n        cmpTemplate: undefined,\n        cmpProps: language_1.create(null),\n        cmpTrack: language_1.create(null),\n        cmpSlots: utils_1.useSyntheticShadow ? language_1.create(null) : undefined,\n        callHook,\n        setHook,\n        getHook,\n        component: undefined,\n        children: utils_1.EmptyArray,\n        aChildren: utils_1.EmptyArray,\n        velements: utils_1.EmptyArray,\n        // used to track down all object-key pairs that makes this vm reactive\n        deps: [],\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        uninitializedVm.toString = () => {\n            return `[object:vm ${def.name} (${uninitializedVm.idx})]`;\n        };\n    }\n    // create component instance associated to the vm and the element\n    component_1.createComponent(uninitializedVm, Ctor);\n    // link component to the wire service\n    const initializedVm = uninitializedVm;\n    component_1.linkComponent(initializedVm);\n}\nexports.createVM = createVM;\nfunction rehydrate(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(vm.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);\n    }\n    if (language_1.isTrue(vm.isDirty)) {\n        const children = component_1.renderComponent(vm);\n        patchShadowRoot(vm, children);\n    }\n}\nfunction patchShadowRoot(vm, newCh) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { cmpRoot, children: oldCh } = vm;\n    vm.children = newCh; // caching the new children collection\n    if (newCh.length > 0 || oldCh.length > 0) {\n        // patch function mutates vnodes by adding the element reference,\n        // however, if patching fails it contains partial changes.\n        if (oldCh !== newCh) {\n            const fn = patch_1.hasDynamicChildren(newCh) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;\n            runWithBoundaryProtection(vm, vm, () => {\n                // pre\n                if (process.env.NODE_ENV !== 'production') {\n                    performance_timing_1.startMeasure('patch', vm);\n                }\n            }, () => {\n                // job\n                fn(cmpRoot, oldCh, newCh);\n            }, () => {\n                // post\n                if (process.env.NODE_ENV !== 'production') {\n                    performance_timing_1.endMeasure('patch', vm);\n                }\n            });\n        }\n    }\n    if (vm.state === VMState.connected) {\n        // If the element is connected, that means connectedCallback was already issued, and\n        // any successive rendering should finish with the call to renderedCallback, otherwise\n        // the connectedCallback will take care of calling it in the right order at the end of\n        // the current rehydration process.\n        runRenderedCallback(vm);\n    }\n}\nfunction runRenderedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { rendered } = services_1.Services;\n    if (rendered) {\n        services_1.invokeServiceHook(vm, rendered);\n    }\n    const { renderedCallback } = vm.def;\n    if (!language_1.isUndefined(renderedCallback)) {\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.startMeasure('renderedCallback', vm);\n        }\n        invoker_1.invokeComponentCallback(vm, renderedCallback);\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.endMeasure('renderedCallback', vm);\n        }\n    }\n}\nlet rehydrateQueue = [];\nfunction flushRehydrationQueue() {\n    performance_timing_1.startGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    }\n    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        const vm = vms[i];\n        try {\n            rehydrate(vm);\n        }\n        catch (error) {\n            if (i + 1 < len) {\n                // pieces of the queue are still pending to be rehydrated, those should have priority\n                if (rehydrateQueue.length === 0) {\n                    utils_1.addCallbackToNextTick(flushRehydrationQueue);\n                }\n                language_1.ArrayUnshift.apply(rehydrateQueue, language_1.ArraySlice.call(vms, i + 1));\n            }\n            // we need to end the measure before throwing.\n            performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);\n            // re-throwing the original error will break the current tick, but since the next tick is\n            // already scheduled, it should continue patching the rest.\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n    performance_timing_1.endGlobalMeasure(performance_timing_1.GlobalMeasurementPhase.REHYDRATE);\n}\nfunction runConnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { state } = vm;\n    if (state === VMState.connected) {\n        return; // nothing to do since it was already connected\n    }\n    vm.state = VMState.connected;\n    // reporting connection\n    const { connected } = services_1.Services;\n    if (connected) {\n        services_1.invokeServiceHook(vm, connected);\n    }\n    const { connectedCallback } = vm.def;\n    if (!language_1.isUndefined(connectedCallback)) {\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.startMeasure('connectedCallback', vm);\n        }\n        invoker_1.invokeComponentCallback(vm, connectedCallback);\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.endMeasure('connectedCallback', vm);\n        }\n    }\n}\nfunction runDisconnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.isTrue(vm.state !== VMState.disconnected, `${vm} must be inserted.`);\n    }\n    if (language_1.isFalse(vm.isDirty)) {\n        // this guarantees that if the component is reused/reinserted,\n        // it will be re-rendered because we are disconnecting the reactivity\n        // linking, so mutations are not automatically reflected on the state\n        // of disconnected components.\n        component_1.markComponentAsDirty(vm);\n    }\n    component_1.clearReactiveListeners(vm);\n    vm.state = VMState.disconnected;\n    // reporting disconnection\n    const { disconnected } = services_1.Services;\n    if (disconnected) {\n        services_1.invokeServiceHook(vm, disconnected);\n    }\n    const { disconnectedCallback } = vm.def;\n    if (!language_1.isUndefined(disconnectedCallback)) {\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.startMeasure('disconnectedCallback', vm);\n        }\n        invoker_1.invokeComponentCallback(vm, disconnectedCallback);\n        if (process.env.NODE_ENV !== 'production') {\n            performance_timing_1.endMeasure('disconnectedCallback', vm);\n        }\n    }\n}\nfunction runShadowChildNodesDisconnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { velements: vCustomElementCollection } = vm;\n    // reporting disconnection for every child in inverse order since they are inserted in reserved order\n    for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n        const elm = vCustomElementCollection[i].elm;\n        // There are two cases where the element could be undefined:\n        // * when there is an error during the construction phase, and an\n        //   error boundary picks it, there is a possibility that the VCustomElement\n        //   is not properly initialized, and therefore is should be ignored.\n        // * when slotted custom element is not used by the element where it is slotted\n        //   into it, as a result, the custom element was never initialized.\n        if (!language_1.isUndefined(elm)) {\n            const childVM = getCustomElementVM(elm);\n            resetComponentStateWhenRemoved(childVM);\n        }\n    }\n}\nfunction runLightChildNodesDisconnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { aChildren: adoptedChildren } = vm;\n    recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\nfunction recursivelyDisconnectChildren(vnodes) {\n    for (let i = 0, len = vnodes.length; i < len; i += 1) {\n        const vnode = vnodes[i];\n        if (!language_1.isNull(vnode) && language_1.isArray(vnode.children) && !language_1.isUndefined(vnode.elm)) {\n            // vnode is a VElement with children\n            if (language_1.isUndefined(vnode.ctor)) {\n                // it is a VElement, just keep looking (recursively)\n                recursivelyDisconnectChildren(vnode.children);\n            }\n            else {\n                // it is a VCustomElement, disconnect it and ignore its children\n                resetComponentStateWhenRemoved(getCustomElementVM(vnode.elm));\n            }\n        }\n    }\n}\n// This is a super optimized mechanism to remove the content of the shadowRoot\n// without having to go into snabbdom. Especially useful when the reset is a consequence\n// of an error, in which case the children VNodes might not be representing the current\n// state of the DOM\nfunction resetShadowRoot(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    vm.children = utils_1.EmptyArray;\n    dom_1.ShadowRootInnerHTMLSetter.call(vm.cmpRoot, '');\n    // disconnecting any known custom element inside the shadow of the this vm\n    runShadowChildNodesDisconnectedCallback(vm);\n}\nexports.resetShadowRoot = resetShadowRoot;\nfunction scheduleRehydration(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    if (!vm.isScheduled) {\n        vm.isScheduled = true;\n        if (rehydrateQueue.length === 0) {\n            utils_1.addCallbackToNextTick(flushRehydrationQueue);\n        }\n        language_1.ArrayPush.call(rehydrateQueue, vm);\n    }\n}\nexports.scheduleRehydration = scheduleRehydration;\nfunction getErrorBoundaryVMFromOwnElement(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    const { elm } = vm;\n    return getErrorBoundaryVM(elm);\n}\nfunction getErrorBoundaryVM(startingElement) {\n    let elm = startingElement;\n    let vm;\n    while (!language_1.isNull(elm)) {\n        vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n        if (!language_1.isUndefined(vm) && !language_1.isUndefined(vm.def.errorCallback)) {\n            return vm;\n        }\n        elm = getParentOrHostElement(elm);\n    }\n}\n/**\n * Returns the component stack. Used for errors messages only.\n *\n * @param {Element} startingElement\n *\n * @return {string} The component stack for errors.\n */\nfunction getErrorComponentStack(startingElement) {\n    const wcStack = [];\n    let elm = startingElement;\n    do {\n        const currentVm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n        if (!language_1.isUndefined(currentVm)) {\n            const tagName = element_1.tagNameGetter.call(elm);\n            const is = elm.getAttribute('is');\n            language_1.ArrayPush.call(wcStack, `<${language_1.StringToLowerCase.call(tagName)}${is ? ' is=\"${is}' : ''}>`);\n        }\n        elm = getParentOrHostElement(elm);\n    } while (!language_1.isNull(elm));\n    return wcStack.reverse().join('\\n\\t');\n}\nexports.getErrorComponentStack = getErrorComponentStack;\n/**\n * Finds the parent of the specified element. If shadow DOM is enabled, finds\n * the host of the shadow root to escape the shadow boundary.\n */\nfunction getParentOrHostElement(elm) {\n    const parentElement = node_1.parentElementGetter.call(elm);\n    // If parentElement is a shadow root, find the host instead\n    return language_1.isNull(parentElement) ? getHostElement(elm) : parentElement;\n}\n/**\n * Finds the host element, if it exists.\n */\nfunction getHostElement(elm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(language_1.isNull(node_1.parentElementGetter.call(elm)), `getHostElement should only be called if the parent element of ${elm} is null`);\n    }\n    const parentNode = node_1.parentNodeGetter.call(elm);\n    return parentNode instanceof GlobalShadowRoot\n        ? dom_1.ShadowRootHostGetter.call(parentNode)\n        : null;\n}\n/**\n * EXPERIMENTAL: This function detects whether or not a Node is\n * controlled by a LWC template. This API is subject to\n * change or being removed.\n */\nfunction isNodeFromTemplate(node) {\n    if (language_1.isFalse(node instanceof Node)) {\n        return false;\n    }\n    // TODO: #1250 - skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker\n    if (node instanceof GlobalShadowRoot) {\n        return false;\n    }\n    if (utils_1.useSyntheticShadow) {\n        // TODO: #1252 - old behavior that is still used by some pieces of the platform, specifically, nodes inserted\n        // manually on places where `lwc:dom=\"manual\"` directive is not used, will be considered global elements.\n        if (language_1.isUndefined(node.$shadowResolver$)) {\n            return false;\n        }\n    }\n    const root = node.getRootNode();\n    return root instanceof GlobalShadowRoot;\n}\nexports.isNodeFromTemplate = isNodeFromTemplate;\nfunction getCustomElementVM(elm) {\n    if (process.env.NODE_ENV !== 'production') {\n        const vm = fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    return fields_1.getInternalField(elm, utils_1.ViewModelReflection);\n}\nexports.getCustomElementVM = getCustomElementVM;\nfunction getComponentVM(component) {\n    if (process.env.NODE_ENV !== 'production') {\n        const vm = fields_1.getHiddenField(component, utils_1.ViewModelReflection);\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    return fields_1.getHiddenField(component, utils_1.ViewModelReflection);\n}\nexports.getComponentVM = getComponentVM;\nfunction getShadowRootVM(root) {\n    // TODO: #1299 - use a weak map instead of an internal field\n    if (process.env.NODE_ENV !== 'production') {\n        const vm = fields_1.getInternalField(root, utils_1.ViewModelReflection);\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    return fields_1.getInternalField(root, utils_1.ViewModelReflection);\n}\nexports.getShadowRootVM = getShadowRootVM;\n// slow path routine\n// NOTE: we should probably more this routine to the synthetic shadow folder\n// and get the allocation to be cached by in the elm instead of in the VM\nfunction allocateInSlot(vm, children) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n        assert_1.default.invariant(language_1.isObject(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);\n    }\n    const { cmpSlots: oldSlots } = vm;\n    const cmpSlots = (vm.cmpSlots = language_1.create(null));\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (language_1.isNull(vnode)) {\n            continue;\n        }\n        const { data } = vnode;\n        const slotName = ((data.attrs && data.attrs.slot) || '');\n        const vnodes = (cmpSlots[slotName] = cmpSlots[slotName] || []);\n        // re-keying the vnodes is necessary to avoid conflicts with default content for the slot\n        // which might have similar keys. Each vnode will always have a key that\n        // starts with a numeric character from compiler. In this case, we add a unique\n        // notation for slotted vnodes keys, e.g.: `@foo:1:1`\n        vnode.key = `@${slotName}:${vnode.key}`;\n        language_1.ArrayPush.call(vnodes, vnode);\n    }\n    if (language_1.isFalse(vm.isDirty)) {\n        // We need to determine if the old allocation is really different from the new one\n        // and mark the vm as dirty\n        const oldKeys = language_1.keys(oldSlots);\n        if (oldKeys.length !== language_1.keys(cmpSlots).length) {\n            component_1.markComponentAsDirty(vm);\n            return;\n        }\n        for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n            const key = oldKeys[i];\n            if (language_1.isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {\n                component_1.markComponentAsDirty(vm);\n                return;\n            }\n            const oldVNodes = oldSlots[key];\n            const vnodes = cmpSlots[key];\n            for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {\n                if (oldVNodes[j] !== vnodes[j]) {\n                    component_1.markComponentAsDirty(vm);\n                    return;\n                }\n            }\n        }\n    }\n}\nexports.allocateInSlot = allocateInSlot;\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n    }\n    let error;\n    pre();\n    try {\n        job();\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        post();\n        if (!language_1.isUndefined(error)) {\n            error.wcStack = error.wcStack || getErrorComponentStack(vm.elm);\n            const errorBoundaryVm = language_1.isNull(owner)\n                ? undefined\n                : getErrorBoundaryVMFromOwnElement(owner);\n            if (language_1.isUndefined(errorBoundaryVm)) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n            resetShadowRoot(vm); // remove offenders\n            if (process.env.NODE_ENV !== 'production') {\n                performance_timing_1.startMeasure('errorCallback', errorBoundaryVm);\n            }\n            // error boundaries must have an ErrorCallback\n            const errorCallback = errorBoundaryVm.def.errorCallback;\n            invoker_1.invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n            if (process.env.NODE_ENV !== 'production') {\n                performance_timing_1.endMeasure('errorCallback', errorBoundaryVm);\n            }\n        }\n    }\n}\nexports.runWithBoundaryProtection = runWithBoundaryProtection;\n//# sourceMappingURL=vm.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assert_1 = __importDefault(require(\"../shared/assert\"));\nconst language_1 = require(\"../shared/language\");\nconst TargetToReactiveRecordMap = new WeakMap();\nfunction notifyMutation(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert_1.default.invariant(!invoker_1.isRendering, `Mutating property ${language_1.toString(key)} of ${language_1.toString(target)} is not allowed during the rendering life-cycle of ${invoker_1.vmBeingRendered}.`);\n    }\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (!language_1.isUndefined(reactiveRecord)) {\n        const value = reactiveRecord[key];\n        if (value) {\n            const len = value.length;\n            for (let i = 0; i < len; i += 1) {\n                const vm = value[i];\n                if (process.env.NODE_ENV !== 'production') {\n                    assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);\n                }\n                if (language_1.isFalse(vm.isDirty)) {\n                    component_1.markComponentAsDirty(vm);\n                    vm_1.scheduleRehydration(vm);\n                }\n            }\n        }\n    }\n}\nexports.notifyMutation = notifyMutation;\nfunction observeMutation(target, key) {\n    if (language_1.isNull(invoker_1.vmBeingRendered)) {\n        return; // nothing to subscribe to\n    }\n    const vm = invoker_1.vmBeingRendered;\n    let reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (language_1.isUndefined(reactiveRecord)) {\n        const newRecord = language_1.create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    let value = reactiveRecord[key];\n    if (language_1.isUndefined(value)) {\n        value = [];\n        reactiveRecord[key] = value;\n    }\n    else if (value[0] === vm) {\n        return; // perf optimization considering that most subscriptions will come from the same vm\n    }\n    if (language_1.ArrayIndexOf.call(value, vm) === -1) {\n        language_1.ArrayPush.call(value, vm);\n        // we keep track of the sets that vm is listening from to be able to do some clean up later on\n        language_1.ArrayPush.call(vm.deps, value);\n    }\n}\nexports.observeMutation = observeMutation;\nconst vm_1 = require(\"./vm\");\nconst component_1 = require(\"./component\");\nconst invoker_1 = require(\"./invoker\");\n//# sourceMappingURL=watcher.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst language_1 = require(\"../shared/language\");\nconst vm_1 = require(\"./vm\");\nconst utils_1 = require(\"./utils\");\nconst def_1 = require(\"./def\");\nconst attributes_1 = require(\"./attributes\");\nconst patch_1 = require(\"./patch\");\nconst restrictions_1 = require(\"./restrictions\");\n/**\n * This function builds a Web Component class from a LWC constructor\n * so it can be registered as a new element via customElements.define()\n * at any given time. E.g.:\n *\n *      import { buildCustomElementConstructor } from 'lwc';\n *      import Foo from 'ns/foo';\n *      const WC = buildCustomElementConstructor(Foo);\n *      customElements.define('x-foo', Foo);\n *      const elm = document.createElement('x-foo');\n *\n */\nfunction buildCustomElementConstructor(Ctor, options) {\n    var _a;\n    const { props, bridge: BaseElement } = def_1.getComponentDef(Ctor);\n    const normalizedOptions = {\n        mode: 'open',\n        isRoot: true,\n        owner: null,\n    };\n    if (language_1.isObject(options) && !language_1.isNull(options)) {\n        const { mode } = options;\n        // TODO: #1300 - use a default value of 'closed'\n        if (mode === 'closed') {\n            normalizedOptions.mode = mode;\n        }\n    }\n    return _a = class extends BaseElement {\n            constructor() {\n                super();\n                if (language_1.isTrue(utils_1.useSyntheticShadow)) {\n                    const def = def_1.getComponentDef(Ctor);\n                    patch_1.patchCustomElementProto(this, {\n                        def,\n                    });\n                }\n                vm_1.createVM(this, Ctor, normalizedOptions);\n                if (process.env.NODE_ENV !== 'production') {\n                    restrictions_1.patchCustomElementWithRestrictions(this, utils_1.EmptyObject);\n                }\n            }\n            connectedCallback() {\n                const vm = vm_1.getCustomElementVM(this);\n                vm_1.appendRootVM(vm);\n            }\n            disconnectedCallback() {\n                const vm = vm_1.getCustomElementVM(this);\n                vm_1.removeRootVM(vm);\n            }\n            attributeChangedCallback(attrName, oldValue, newValue) {\n                if (oldValue === newValue) {\n                    // ignoring similar values for better perf\n                    return;\n                }\n                const propName = attributes_1.getPropNameFromAttrName(attrName);\n                if (language_1.isUndefined(props[propName])) {\n                    // ignoring unknown attributes\n                    return;\n                }\n                if (!attributes_1.isAttributeLocked(this, attrName)) {\n                    // ignoring changes triggered by the engine itself during:\n                    // * diffing when public props are attempting to reflect to the DOM\n                    // * component via `this.setAttribute()`, should never update the prop.\n                    // Both cases, the the setAttribute call is always wrap by the unlocking\n                    // of the attribute to be changed\n                    return;\n                }\n                // reflect attribute change to the corresponding props when changed\n                // from outside.\n                this[propName] = newValue;\n            }\n        },\n        // collecting all attribute names from all public props to apply\n        // the reflection from attributes to props via attributeChangedCallback.\n        _a.observedAttributes = language_1.ArrayMap.call(language_1.getOwnPropertyNames(props), propName => props[propName].attr),\n        _a;\n}\nexports.buildCustomElementConstructor = buildCustomElementConstructor;\n//# sourceMappingURL=wc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect(propName) {\n    return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;\n}\nexports.detect = detect;\n//# sourceMappingURL=detect.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst detect_1 = require(\"./detect\");\nconst polyfill_1 = require(\"./polyfill\");\n// Global Aria and Role Properties derived from ARIA and Role Attributes.\n// https://wicg.github.io/aom/spec/aria-reflection.html\nexports.ElementPrototypeAriaPropertyNames = [\n    'ariaAutoComplete',\n    'ariaChecked',\n    'ariaCurrent',\n    'ariaDisabled',\n    'ariaExpanded',\n    'ariaHasPopup',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaLabel',\n    'ariaLevel',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRequired',\n    'ariaSelected',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'ariaLive',\n    'ariaRelevant',\n    'ariaAtomic',\n    'ariaBusy',\n    'ariaActiveDescendant',\n    'ariaControls',\n    'ariaDescribedBy',\n    'ariaFlowTo',\n    'ariaLabelledBy',\n    'ariaOwns',\n    'ariaPosInSet',\n    'ariaSetSize',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaDetails',\n    'ariaErrorMessage',\n    'ariaKeyShortcuts',\n    'ariaModal',\n    'ariaPlaceholder',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowSpan',\n    'ariaColSpan',\n    'role',\n];\n/**\n * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in\n * ARIA 1.1 and do not have corresponding IDL attributes.\n */\nfor (let i = 0, len = exports.ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n    const propName = exports.ElementPrototypeAriaPropertyNames[i];\n    if (detect_1.detect(propName)) {\n        polyfill_1.patch(propName);\n    }\n}\n//# sourceMappingURL=main.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst element_1 = require(\"../../env/element\");\n// this regular expression is used to transform aria props into aria attributes because\n// that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`\nconst ARIA_REGEX = /^aria/;\nconst nodeToAriaPropertyValuesMap = new WeakMap();\nconst { hasOwnProperty } = Object.prototype;\nconst { replace: StringReplace, toLowerCase: StringToLowerCase } = String.prototype;\nfunction getAriaPropertyMap(elm) {\n    let map = nodeToAriaPropertyValuesMap.get(elm);\n    if (map === undefined) {\n        map = {};\n        nodeToAriaPropertyValuesMap.set(elm, map);\n    }\n    return map;\n}\nfunction getNormalizedAriaPropertyValue(value) {\n    return value == null ? null : value + '';\n}\nfunction createAriaPropertyPropertyDescriptor(propName, attrName) {\n    return {\n        get() {\n            const map = getAriaPropertyMap(this);\n            if (hasOwnProperty.call(map, propName)) {\n                return map[propName];\n            }\n            // otherwise just reflect what's in the attribute\n            return element_1.hasAttribute.call(this, attrName) ? element_1.getAttribute.call(this, attrName) : null;\n        },\n        set(newValue) {\n            const normalizedValue = getNormalizedAriaPropertyValue(newValue);\n            const map = getAriaPropertyMap(this);\n            map[propName] = normalizedValue;\n            // reflect into the corresponding attribute\n            if (newValue === null) {\n                element_1.removeAttribute.call(this, attrName);\n            }\n            else {\n                element_1.setAttribute.call(this, attrName, newValue);\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    };\n}\nfunction patch(propName) {\n    // Typescript is inferring the wrong function type for this particular\n    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n    // @ts-ignore type-mismatch\n    const replaced = StringReplace.call(propName, ARIA_REGEX, 'aria-');\n    const attrName = StringToLowerCase.call(replaced);\n    const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);\n    Object.defineProperty(Element.prototype, propName, descriptor);\n}\nexports.patch = patch;\n//# sourceMappingURL=polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect() {\n    // Don't apply polyfill when ProxyCompat is enabled.\n    if ('getKey' in Proxy) {\n        return false;\n    }\n    const proxy = new Proxy([3, 4], {});\n    const res = [1, 2].concat(proxy);\n    return res.length !== 4;\n}\nexports.default = detect;\n//# sourceMappingURL=detect.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst detect_1 = __importDefault(require(\"./detect\"));\nconst polyfill_1 = __importDefault(require(\"./polyfill\"));\nif (detect_1.default()) {\n    polyfill_1.default();\n}\n//# sourceMappingURL=main.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { isConcatSpreadable } = Symbol;\nconst { isArray } = Array;\nconst { slice: ArraySlice, unshift: ArrayUnshift, shift: ArrayShift } = Array.prototype;\nfunction isObject(O) {\n    return typeof O === 'object' ? O !== null : typeof O === 'function';\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\nfunction isSpreadable(O) {\n    if (!isObject(O)) {\n        return false;\n    }\n    const spreadable = O[isConcatSpreadable];\n    return spreadable !== undefined ? Boolean(spreadable) : isArray(O);\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat\nfunction ArrayConcatPolyfill(..._args) {\n    const O = Object(this);\n    const A = [];\n    let N = 0;\n    const items = ArraySlice.call(arguments);\n    ArrayUnshift.call(items, O);\n    while (items.length) {\n        const E = ArrayShift.call(items);\n        if (isSpreadable(E)) {\n            let k = 0;\n            const length = E.length;\n            for (k; k < length; k += 1, N += 1) {\n                if (k in E) {\n                    const subElement = E[k];\n                    A[N] = subElement;\n                }\n            }\n        }\n        else {\n            A[N] = E;\n            N += 1;\n        }\n    }\n    return A;\n}\nfunction apply() {\n    Array.prototype.concat = ArrayConcatPolyfill;\n}\nexports.default = apply;\n//# sourceMappingURL=polyfill.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"./language\");\nconst element_1 = require(\"../env/element\");\nconst node_1 = require(\"../env/node\");\nconst dom_1 = require(\"../env/dom\");\nfunction isLWC(element) {\n    return element instanceof Element && element_1.tagNameGetter.call(element).indexOf('-') !== -1;\n}\nfunction isShadowRoot(elmOrShadow) {\n    return !(elmOrShadow instanceof Element) && 'host' in elmOrShadow;\n}\nfunction getFormattedComponentStack(elm) {\n    const componentStack = [];\n    const indentationChar = '\\t';\n    let indentation = '';\n    let currentElement = elm;\n    do {\n        if (isLWC(currentElement)) {\n            language_1.ArrayPush.call(componentStack, `${indentation}<${language_1.StringToLowerCase.call(element_1.tagNameGetter.call(currentElement))}>`);\n            indentation = indentation + indentationChar;\n        }\n        if (isShadowRoot(currentElement)) {\n            // if at some point we find a ShadowRoot, it must be a native shadow root.\n            currentElement = dom_1.ShadowRootHostGetter.call(currentElement);\n        }\n        else {\n            currentElement = node_1.parentNodeGetter.call(currentElement);\n        }\n    } while (!language_1.isNull(currentElement));\n    return language_1.ArrayJoin.call(componentStack, '\\n');\n}\nconst assert = {\n    invariant(value, msg) {\n        if (!value) {\n            throw new Error(`Invariant Violation: ${msg}`);\n        }\n    },\n    isTrue(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n    isFalse(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n    fail(msg) {\n        throw new Error(msg);\n    },\n    logError(message, elm) {\n        let msg = `[LWC error]: ${message}`;\n        if (elm) {\n            msg = `${msg}\\n${getFormattedComponentStack(elm)}`;\n        }\n        if (process.env.NODE_ENV === 'test') {\n            /* eslint-disable-next-line no-console */\n            console.error(msg);\n            return;\n        }\n        try {\n            throw new Error(msg);\n        }\n        catch (e) {\n            /* eslint-disable-next-line no-console */\n            console.error(e);\n        }\n    },\n};\nexports.default = assert;\n//# sourceMappingURL=assert.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst language_1 = require(\"./language\");\n/**\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when transpiling.\n */\nconst hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';\nfunction createFieldName(key) {\n    // @ts-ignore: using a string as a symbol for perf reasons\n    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;\n}\nexports.createFieldName = createFieldName;\nfunction setInternalField(o, fieldName, value) {\n    // TODO: #1299 - use a weak map instead\n    language_1.defineProperty(o, fieldName, {\n        value,\n    });\n}\nexports.setInternalField = setInternalField;\nfunction getInternalField(o, fieldName) {\n    return o[fieldName];\n}\nexports.getInternalField = getInternalField;\n/**\n * Store fields that should be hidden from outside world\n * hiddenFieldsMap is a WeakMap.\n * It stores a hash of any given objects associative relationships.\n * The hash uses the fieldName as the key, the value represents the other end of the association.\n *\n * For example, if the association is\n *              ViewModel\n * Component-A --------------> VM-1\n * then,\n * hiddenFieldsMap : (Component-A, { Symbol(ViewModel) : VM-1 })\n *\n */\nconst hiddenFieldsMap = new WeakMap();\nexports.setHiddenField = hasNativeSymbolsSupport\n    ? (o, fieldName, value) => {\n        let valuesByField = hiddenFieldsMap.get(o);\n        if (language_1.isUndefined(valuesByField)) {\n            valuesByField = language_1.create(null);\n            hiddenFieldsMap.set(o, valuesByField);\n        }\n        valuesByField[fieldName] = value;\n    }\n    : setInternalField; // Fall back to symbol based approach in compat mode\nexports.getHiddenField = hasNativeSymbolsSupport\n    ? (o, fieldName) => {\n        const valuesByField = hiddenFieldsMap.get(o);\n        return !language_1.isUndefined(valuesByField) && valuesByField[fieldName];\n    }\n    : getInternalField; // Fall back to symbol based approach in compat mode\n//# sourceMappingURL=fields.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, hasOwnProperty, } = Object;\nexports.freeze = freeze;\nexports.seal = seal;\nexports.keys = keys;\nexports.create = create;\nexports.assign = assign;\nexports.defineProperty = defineProperty;\nexports.getPrototypeOf = getPrototypeOf;\nexports.setPrototypeOf = setPrototypeOf;\nexports.getOwnPropertyDescriptor = getOwnPropertyDescriptor;\nexports.getOwnPropertyNames = getOwnPropertyNames;\nexports.defineProperties = defineProperties;\nexports.hasOwnProperty = hasOwnProperty;\nconst { isArray } = Array;\nexports.isArray = isArray;\nconst { slice: ArraySlice, splice: ArraySplice, unshift: ArrayUnshift, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, join: ArrayJoin, forEach, reduce: ArrayReduce, } = Array.prototype;\nexports.ArraySlice = ArraySlice;\nexports.ArraySplice = ArraySplice;\nexports.ArrayUnshift = ArrayUnshift;\nexports.ArrayIndexOf = ArrayIndexOf;\nexports.ArrayPush = ArrayPush;\nexports.ArrayMap = ArrayMap;\nexports.ArrayJoin = ArrayJoin;\nexports.forEach = forEach;\nexports.ArrayReduce = ArrayReduce;\nconst { replace: StringReplace, toLowerCase: StringToLowerCase, charCodeAt: StringCharCodeAt, slice: StringSlice, } = String.prototype;\nexports.StringReplace = StringReplace;\nexports.StringToLowerCase = StringToLowerCase;\nexports.StringCharCodeAt = StringCharCodeAt;\nexports.StringSlice = StringSlice;\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nexports.isUndefined = isUndefined;\nfunction isNull(obj) {\n    return obj === null;\n}\nexports.isNull = isNull;\nfunction isTrue(obj) {\n    return obj === true;\n}\nexports.isTrue = isTrue;\nfunction isFalse(obj) {\n    return obj === false;\n}\nexports.isFalse = isFalse;\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nexports.isFunction = isFunction;\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\nexports.isObject = isObject;\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nexports.isString = isString;\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nexports.isNumber = isNumber;\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        // Arrays might hold objects with \"null\" prototype\n        // So using Array.prototype.toString directly will cause an error\n        // Iterate through all the items and handle individually.\n        if (isArray(obj)) {\n            return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + exports.emptyString;\n    }\n}\nexports.toString = toString;\nfunction getPropertyDescriptor(o, p) {\n    do {\n        const d = getOwnPropertyDescriptor(o, p);\n        if (!isUndefined(d)) {\n            return d;\n        }\n        o = getPrototypeOf(o);\n    } while (o !== null);\n}\nexports.getPropertyDescriptor = getPropertyDescriptor;\nexports.emptyString = '';\n//# sourceMappingURL=language.js.map"],"sourceRoot":""}